
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>1Feng's Blog</title>
	<meta name="author" content="Travis Swicegood">

	
	<meta name="description" content="What Atomicity 描述： 一个事务包含一系列的操作，这一系列的操作都成功，则意味着事务执行成功；一旦执行过程中发生故障(fault)，数据库需要放弃整个事务，并且撤销已经完成的部分操作 优势： 方便异常处理，如果事务终止，应用层面可以确保什么修改都没有发生，可以安全的重试 典型案例 &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom/" rel="alternate" title="1Feng's Blog" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="/javascripts/jquery.min.js"></script>
	
</head>


<body>
	<header id="header" class="inner"><h1><a href="/">1Feng's Blog</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="http://google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:1feng.github.io">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		
		
		<a class="github" href="https://github.com/1feng" title="GitHub">GitHub</a>
		
    
		
		
		
		
		
		<a class="rss" href="/atom/" title="RSS">RSS</a>
		
    
	</div>
	<form class="search" action="http://google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:1feng.github.io">
	</form>
</nav>

</header>
	
		

	
	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/2017/06/07/ACID/">
		
			What Is ACID</a>
	</h2>
	<div class="entry-content">
		<h1>What</h1>

<h2>Atomicity</h2>

<p><strong>描述</strong>：</p>

<p>一个事务包含一系列的操作，这一系列的操作都成功，则意味着事务执行成功；一旦执行过程中发生故障(fault)，数据库需要放弃整个事务，并且撤销已经完成的部分操作</p>

<p><strong>优势</strong>：</p>

<p>方便异常处理，如果事务终止，应用层面可以确保什么修改都没有发生，可以安全的重试</p>

<p><strong>典型案例</strong>：</p>

<p>A向B账户转账100元：
 1. 从A的账户减少100元
 2. 从B的账户增加100元</p>

<p>如果1执行完成2还未执行，此时数据库故障(<code>system fails</code>)，则为了保证Atomicity，数据库的事务系统需要回滚1操作</p>

<p><strong>其他</strong>：</p>

<blockquote><p>这里需要与concurrency-atomic做一下区分, concurrency-atomic指的是当某个线程执行某个操作时，其他线程不可能看到中间状态(half-finished)</p></blockquote>

<h2>Consistency</h2>

<p><strong>描述</strong>：</p>

<p>这里的consistency是指，当事务结束时，系统（数据库）处于一个合法的状态(valid state),也就是说系统总是从一个合法的状态迁移至另一个合法的状态</p>

<p><strong>其他</strong>：</p>

<ol>
<li>ACID-consistency是一个比较模糊的概念，状态迁移是系统的用户来保证的，系统只能保证其中一部分，不能完全覆盖，所以consistency依赖用户而不是系统</li>
<li>MSDN给出的例子<a href="https://msdn.microsoft.com/en-us/library/aa480356.aspx">[2]</a>和Atomicity类似，但是差别在于A中事务终止回滚时因为system fails，而C中事务终止回滚是因为error（比如类型不匹配，数字和字符串做加法？）</li>
<li>ACID-consistency 和CAP-consistency直接没有任何关系，仅仅使用了同一个单词而已</li>
</ol>


<h2>Islation</h2>

<p><strong>描述</strong>：</p>

<p>Isolation是指当多个事务并发(concurrency)执行时，应该彼此之间存在隔离，执行过程中互不影响</p>

<h2>Durability</h2>

<p><strong>描述</strong>：</p>

<p>一旦事务成功提交，即使发生硬件故障或者程序崩溃，任何已经写入的数据都不能丢失</p>

<h1>How</h1>

<h2>Atomicity ★★★★</h2>

<p>可以利用持久化日志来实现，方便重启回滚</p>

<h2>Consistency ★★</h2>

<p>数据库层面做足够的合法性检测，其他由用户层/应用层来保证</p>

<h2>Islation ★★★★★</h2>

<p><strong>先看几点要求</strong>：</p>

<ul>
<li>Read commited（weak-islation type） 的两点要求

<ul>
<li>No Dirty Read: 不会读取到其他正在执行的事务中间状体的数据</li>
<li>No Dirty Write: 事务不会overwrite到其他事务的uncommitted的数据</li>
</ul>
</li>
<li>No Read Skew：

<ul>
<li>Read Skew举例：

<ul>
<li>A 在两个账户中各存放了500块钱，现在A要查询两个账户的余额</li>
<li>查询账户1的SQL执行完成，余额500</li>
<li>假设A之前设置了一笔定时的自动转账被触发，从账户2向账户1转100块，事务执行成功，账户1余额600，账户2余额400</li>
<li>查询账户2的SQL执行完成，余额400</li>
<li>在A看来，账户总额少了100块</li>
<li>即使如此这个场景还是可以接受的，因为A可以重新查询，即可获得正常结果</li>
</ul>
</li>
<li>无法接受Read Skew的两个场景：

<ul>
<li>Backup

<ul>
<li>事务执行的同时，可以完成数据备份</li>
</ul>
</li>
<li>Analytic Queries and Integrity checks

<ul>
<li>事务执行的同时, 需要完成大量数据的查询或扫描</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Read-Modify-Write / Atomic Write Operation

<ul>
<li>举例：两个用户同时对一个counter字段做inc操作，后果与多线程并发操作类似会丢失一部分inc操作</li>
</ul>
</li>
<li>Write Skew

<ul>
<li>举例（针对multi-object的场景）：

<ul>
<li>两位医生Alice 和 Bob同时检查当前是否有另外一个人正在值班，如果有则在系统中停止自己的值班状态，然后回家睡觉</li>
</ul>
</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="n">Alice</span><span class="err">执行事务如下：</span>
</span><span class='line'><span class="n">currently_on_call</span> <span class="o">=</span> <span class="p">(</span><span class="k">select</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">from</span> <span class="n">doctors</span> <span class="k">where</span> <span class="n">on_call</span> <span class="o">=</span> <span class="k">true</span> <span class="k">and</span> <span class="n">shift_id</span> <span class="o">=</span> <span class="mi">1234</span><span class="p">)</span>
</span><span class='line'><span class="n">if</span> <span class="p">(</span><span class="n">currently_on_call</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="err">{</span>
</span><span class='line'>    <span class="k">update</span> <span class="n">doctors</span> <span class="k">set</span> <span class="n">on_call</span> <span class="o">=</span> <span class="k">true</span> <span class="k">where</span> <span class="n">name</span><span class="o">=</span><span class="err">‘</span><span class="n">Alice</span><span class="err">’</span> <span class="k">and</span> <span class="n">shift_id</span> <span class="o">=</span> <span class="mi">1234</span>
</span><span class='line'><span class="err">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">Bob</span><span class="err">执行事务如下：</span>
</span><span class='line'><span class="n">currently_on_call</span> <span class="o">=</span> <span class="p">(</span><span class="k">select</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">from</span> <span class="n">doctors</span> <span class="k">where</span> <span class="n">on_call</span> <span class="o">=</span> <span class="k">true</span> <span class="k">and</span> <span class="n">shift_id</span> <span class="o">=</span> <span class="mi">1234</span><span class="p">)</span>
</span><span class='line'><span class="n">if</span> <span class="p">(</span><span class="n">currently_on_call</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="err">{</span>
</span><span class='line'>    <span class="k">update</span> <span class="n">doctors</span> <span class="k">set</span> <span class="n">on_call</span> <span class="o">=</span> <span class="k">true</span> <span class="k">where</span> <span class="n">name</span><span class="o">=</span><span class="err">‘</span><span class="n">Bob</span><span class="err">’</span> <span class="k">and</span> <span class="n">shift_id</span> <span class="o">=</span> <span class="mi">1234</span>
</span><span class='line'><span class="err">}</span>
</span><span class='line'>
</span><span class='line'><span class="err">有点像是</span><span class="n">multi</span><span class="o">-</span><span class="k">object</span><span class="err">版本的</span><span class="k">read</span><span class="o">-</span><span class="k">modify</span><span class="o">-</span><span class="k">write</span><span class="err">，但是有本质区别</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>解决方案</strong>：</p>

<ul>
<li>Read commited

<ul>
<li>Dirty Write: 可以使用row-level lock来避免dirty write</li>
<li>Dirty Read:

<ul>
<li>同样可以使用row-level lock来避免dirty read,但是缺点在于一个比较耗时的写操作会阻塞住read-only的操作，更严重的是会因此引发连锁反应</li>
<li>更好的解决方法是使用类似于MVCC的snapshot-isolation方案来解决dirty read的问题</li>
</ul>
</li>
</ul>
</li>
<li>No Read Skew

<ul>
<li>类似于MVCC的snapshot-isolation方案来解决read skew问题，可同时满足Backup和Analytic Queries and Integrity checks的需求</li>
</ul>
</li>
<li>Read-Modiry-Write / Atomic Write Operation

<ul>
<li>使用显示的锁操作(explicit-locking)来实现atomic write operation</li>
<li>automatically-detecting-lost-update，一旦检测到lost update，事务需要终止并且retry</li>
<li>实现compare-and-set操作用以支持SQL-where语句</li>
</ul>
</li>
<li>Write Skew

<ul>
<li>串行化（serializability）隔离所有事务，这种方式可以解决上述除read skew外所有问题，但是工程实现上往往性能会是一个非常大的问题</li>
</ul>
</li>
</ul>


<blockquote><p>通常为了实现isolation，都是综合以上各种方案</p></blockquote>

<h2>Durability ★★★★</h2>

<p>磁盘+replica</p>

<h1>Serializability</h1>

<h2>What</h2>

<blockquote><p>serializable-isolation 是最强等级的事务并发隔离，他可以确保即使多个事务是并行(parallel)执行的,最终的结果看起来也像是顺序的（serially），每个时间点只有一个事务在执行</p></blockquote>

<h2>How</h2>

<blockquote><p>根据上述描述，不难看出，其要求是让数据库解决所有的可能的并发竞争问题</p></blockquote>

<ul>
<li>真的串行化的执行事务：</li>
<li>方法：将所有的事务扔到一个队列里排队，由特定的线程来依次执行</li>
<li>缺点：性能太差</li>
<li>存储过程（stored procedures）+ in-memory data：</li>
<li>解释：本质是加快单个事务的执行速度（没有了磁盘IO），以便可以真正串行化事务执行</li>
<li>缺点：存储过程需要用户自己来用SQL/PL完成，调试测试监控都比较棘手，同时一旦用户完成的存储过程性能比较差，会造成恶劣的影响，甚至引发连锁反应</li>
<li>数据分区(partitioning)</li>
<li>解释：本质是将单机的性能问题通过scale out来加速</li>
<li>缺点：事务执行涉及的数据不能跨分区</li>
<li>Two-Phase-Locking(2PL)</li>
<li>描述：

<ul>
<li>当事务需要读一个object时，必须先以shared mode获取锁；多个事务可以同时以shared mode获取锁，但是一旦有事务以exclusive mode持有了锁，其他事务必须等待</li>
<li>如果事务想要写一个object，必须先以exclusive mode获取锁；区别于shared mode，同一时间只能有一个事务以exclusive mode持有锁</li>
<li>如果事务先读一个object，然后又要写（read-modify-write）,则需要将锁从shared mode升级为exclusive mode</li>
<li>一旦事务获取了锁，除非事务提交或者终止，否则不允许释放锁，这也是二阶段命名的由来；</li>
</ul>
</li>
<li>解释：

<ul>
<li>Expanding phase（扩大阶段&#8211;事务执行中）: locks are acquired and no locks are released.</li>
<li>Shrinking phase（收缩阶段&#8211;事务结束时）: locks are released and no locks are acquired.</li>
</ul>
</li>
<li>缺点：

<ul>
<li>吞吐量(through-put) 和 响应时间 与仅实现weak-isolation(如read-commit + No Read Skew)相比会比较差</li>
<li>deadlock风险增大</li>
</ul>
</li>
<li>Serializable Snapshot Isolation(SSI)</li>
<li>与之前提到的snapshot-isolation相比，SSI为写操作增加了串行(serialization)冲突检测

<ul>
<li>detecting stale MVCC reads：针对write skew，如果事务提交时检测到之前的前置条件已经不成立了，则终止事务</li>
<li>detecting writes that affect prior read：同样考虑write skew，数据库从index-level/table-level保存一些信息，以便当事务提交后可以检测其操作是否造成其他正在执行的事务读取的数据过期（前置条件失效），如果存在则主动通知该事务终止</li>
</ul>
</li>
</ul>


<h2>Serializability VS Linearizability</h2>

<ul>
<li>serializability： 事务隔离的属性，指事务执行的结果看起来像顺序的（串行的），以避免write skew</li>
<li>linearizability： 指对读写共享数据的新近性（recency guarantee），与事务（把一系列操作看做整体来讨论）无关</li>
</ul>


<h1>References</h1>

<p>[1]. <a href="http://dataintensive.net/">Martin Kleppmann. 《Designing Data-Intensive Applications》7.Transactions</a></p>

<p>[2]. <a href="https://msdn.microsoft.com/en-us/library/aa480356.aspx">ACID properties</a></p>

<p>[3]. <a href="http://www.bailis.org/blog/linearizability-versus-serializability/Linearizability">Linearizability versus Serializability</a></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2017-06-07T23:59:00+08:00" pubdate data-updated="true">Jun 7<span>th</span>, 2017</time></div>
	<div class="tags">


	<a class='category' href='/tags/distribute/'>distribute</a>, <a class='category' href='/tags/system/'>system</a>


</div>
	
	<div class="comments"><a href="/2017/06/07/ACID/#duoshuo">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/2017/06/06/unreliable-network/">
		
			Unreliable Network</a>
	</h2>
	<div class="entry-content">
		<h1>Introduce</h1>

<blockquote><p>众所周知TCP是可靠的网络传输协议，但是为什么在分布式系统中又认为网络是不可靠的呢？通常有以下两点：
1. 发送方无法确定接收方已经收到请求
2. 发送方无法无法知晓接收方是否处理完请求</p>

<p>可以看出，以上指的都是从应用层的角度观察的结果，而引起以上问题的原因可能有：
- 消息在路由队列中等待转发
- 接收方队列满，发生丢包
- 接收方处理完成，回复的消息在排队或发生丢包
- gc-stop-the-world等</p></blockquote>

<h2>Synchronous network</h2>

<p>像电话网络，有线电视网络等都是所谓synchronous network，他的特点如下：</p>

<ul>
<li><p>一旦连接建立，即享用专线</p></li>
<li><p>专线享有固定的带宽</p></li>
<li><p>路由(routers)没有队列</p></li>
</ul>


<p>以上决定了synchronous network的最大网络延迟是固定有上限的，即可以用timeout来判断消息传输是否存在问题</p>

<h2>Asynchronous network</h2>

<p>既然有synchronous network为什么还要搞以太网这一套呢？原因是为了充分利用带宽，由于互联网上数据传输的大小都不是固定的，使用专线意味着带宽资源的浪费。</p>

<p>因此，Ehernet &amp;&amp; ip 使用了packed-switched协议, 具体如下：</p>

<ol>
<li><p>路由引入队列，最大化线路使用率</p></li>
<li><p>TCP层引入send buffer &amp;&amp; recv buffer来动态的适配数据传输速率(滑动窗口)</p></li>
</ol>


<p>上述的优化本质是在latency和resource utilization之间做trade-off，也因此导致了无上限的延迟时间，即无法选择一个合适的timeoout来进行传输故障检测</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2017-06-06T23:59:00+08:00" pubdate data-updated="true">Jun 6<span>th</span>, 2017</time></div>
	<div class="tags">


	<a class='category' href='/tags/distribute/'>distribute</a>, <a class='category' href='/tags/system/'>system</a>


</div>
	
	<div class="comments"><a href="/2017/06/06/unreliable-network/#duoshuo">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/2017/06/05/timing-and-order/">
		
			Timing and Order</a>
	</h2>
	<div class="entry-content">
		<h1>Introduce</h1>

<blockquote><p>分布式环境面临的两个主要的问题就是网络不可靠和时钟不可靠，这里主要总结时钟问题</p></blockquote>

<h2>Physical Clocks</h2>

<p>我们日常使用的计算机和服务器的物理时钟都是使用的石英(quartz)时钟，这类时钟天生存在误差，虽然铯原子钟的精度更高但是造价昂贵，并不适合商用计算机。</p>

<p>对于商用计算机的时钟误差，通常使用NTP协议来进行时钟同步，然而由于网络的不可靠以及时钟误差NTP同步也会有些问题。</p>

<p>商用计算机利用时英时钟在计算机上实现了两种clock:</p>

<ul>
<li><p>wall clock</p>

<ul>
<li>受NTP同步的影响，时钟会jump forward 或 jump backward来完成时钟同步</li>
<li>如linux上的int gettimeofday(struct timeval <em>tv, struct timezone </em>tz);,返回1970-01-01 00:00:00 +0000 (UTC)至今的秒数和豪秒数</li>
</ul>
</li>
<li><p>monotonic clock</p>

<ul>
<li>不受NTP影响，或者，受NTP同步的影响，时钟只会降低或者升高频率，以尽快完成时钟同步</li>
<li>如linux上的int clock_gettime(clockid_t clk_id, struct timespec *tp),clk_id为CLOCK_MONOTONIC_RAW(本质是jiffies)或者是CLOCK_MONOTONIC；分别对应上述不受NTP影响和受NTP影响两种</li>
</ul>
</li>
</ul>


<p>适用性：</p>

<ul>
<li>wall clock

<ul>
<li>适用于：

<ul>
<li>单机保证时序</li>
</ul>
</li>
<li>不适用：

<ul>
<li>单机计算duration或elapsed time，例如统计timeout，expire</li>
<li>分布式环境下的时序问题</li>
</ul>
</li>
</ul>
</li>
<li>monotonic clock

<ul>
<li>适用于：

<ul>
<li>单机计算duration或elapsed time，例如统计timeout，expire</li>
<li>单机保证时序</li>
</ul>
</li>
<li>不适用：

<ul>
<li>分布式环境下时序问题</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>那么分布式环境下的时序问题如何解决呢?</p>

<ul>
<li>全序(total order)或者高精度的时间点共识(强调某个时间点)：

<ul>
<li>使用原子钟加更严格复杂的时钟同步策略来保证误差</li>
<li>fault-tolent total ordering broadcast</li>
</ul>
</li>
<li>偏序（partial order）：

<ul>
<li>利用因果关系来解决时序问题，即logic clock</li>
</ul>
</li>
</ul>


<h2>Logic Clock</h2>

<p>利用因果关系来实现Logic Clock，见Lamport的<a href="https://github.com/1Feng/learn-distributed-systems/tree/master/theory/timing-and-order/Time-Clocks-and-the-Ordering-of-Events-in-a-Distributed-System">论文</a></p>

<p>利用Logic Clock来保证时序(偏序)，见 <a href="https://github.com/1Feng/learn-distributed-systems/tree/master/theory/timing-and-order/vector-clock">Vector Clock</a></p>

<h2>其他</h2>

<p>一个错误使用wall clock的<a href="http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html">案例</a></p>

<h2>References</h2>

<ol>
<li><a href="http://dataintensive.net/">《Designing Data-Intensive Applications》8.Unreliable Clocks</a></li>
<li><a href="http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html">How to do distributed locking</a></li>
<li><a href="https://github.com/1Feng/learn-distributed-systems/tree/master/theory/timing-and-order/Time-Clocks-and-the-Ordering-of-Events-in-a-Distributed-System">《Time-Clocks-and-the-Ordering-of-Events-in-a-Distributed-System》</a></li>
<li><a href="https://github.com/1Feng/learn-distributed-systems/tree/master/theory/timing-and-order/vector-clock">Vector Clock</a></li>
</ol>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2017-06-05T23:59:00+08:00" pubdate data-updated="true">Jun 5<span>th</span>, 2017</time></div>
	<div class="tags">


	<a class='category' href='/tags/distribute/'>distribute</a>, <a class='category' href='/tags/system/'>system</a>


</div>
	
	<div class="comments"><a href="/2017/06/05/timing-and-order/#duoshuo">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/2017/06/05/vector-clock/">
		
			Vector Clock Summary</a>
	</h2>
	<div class="entry-content">
		<h1>Summary</h1>

<h3>Happend before</h3>

<p>用→来表示<code>hanppend before</code>，对于任意event a, b 有：</p>

<ol>
<li>如果a和b属于同一个process，并且a comes before b, 则 a → b</li>
<li>如果a是某个process发送信息的event，b是另一个process接收该信息的event，那么 a → b</li>
<li>如果 a → b并且 b → c，那么 a → c</li>
</ol>


<p>以上本质是基于一个因果关系(causality)来定义的<code>hanppend before</code></p>

<h1>Summary</h1>

<h3>Why</h3>

<p>Lammport Clock(Logical Clock) 只能通过因果关系推断其Logical Clock的关系，即：</p>

<ul>
<li>如果a → b, 则C(a) &lt; C(b), 反过来并不一定成立（其实就是事后诸葛亮，事件先发生才产生因果关系），同时：

<ul>
<li>同一个process上的两个事件由a → b 得到C(a) &lt; C(b),</li>
<li>但是a,b可能因为和另一个process上的事件c没有因果关系处于并发状态</li>
<li>但是按照Lammport的描述的Logic Clock的实现，C(c)很有可能满足 C(a) &lt; C(c) &lt; C(b)</li>
<li>然而实际情况是c和a,c和b均无因果关系</li>
</ul>
</li>
</ul>


<p>Vector Clock的出现就是为了解决上述问题。</p>

<h3>What</h3>

<p>假设有n个processes，V为n个processes上的事件集合，a,b∈V；</p>

<p>对于vector clock 如果VC(a) &lt; VC(b),仅且仅当：</p>

<ul>
<li>∀i: 0 &lt;= i &lt;= n - 1: VCi(a) &lt;= VCi(b)</li>
<li>∃j: 0 &lt;= j &lt;= n - 1: VCj(a) &lt; VCj(b)</li>
</ul>


<p>通俗的讲就是向量维度匹配并且VC(a)的所有维度都不大于VC(b)并且至少有一个维度小于VC(b),这时候VC(a) &lt; VC(b)</p>

<p>同时：<code>VC(a) &lt; VC(b)   &lt;==&gt; a  → b</code></p>

<h3>How</h3>

<p>processes编号0&#8211;n-1, VC利用数组实现，下标从0到n-1，初始为[0,0,0&#8230;0]</p>

<ol>
<li>对于process i，本地的VC为VCi，对于任意事件发生后 ++VCi[i]</li>
<li>当i向其他process发送数据时，带上本地的VCi</li>
<li>当process j接收到VCi时</li>
<li>++VCj[j]</li>
<li>∀k : 0 &lt;= k &lt;= n - 1:  VCj[k] = max(VCi[k], VCj[k])</li>
</ol>


<h3>Weakness</h3>

<ol>
<li>partial order not total order</li>
<li>无法满足VC(a) &lt; VC(b)时还是无法解决order问题。dynamo论文中的提到的处理方式是将该问题抛给client根据业务处理（PS：dynamo据说已经不用vector clock了）</li>
<li>vector size 随着processes数量线性增长
 - Riak开发者提供了一种<a href="http://basho.com/posts/technical/why-vector-clocks-are-hard/">解决方案</a>,在vector clock中带上各自processes的本地time stamp，当vector size到达指定的阈值后，删除最旧的process在vector clock中的数据；这样造成的问题就是丢失了和最旧的process的因果关系，按照作者的说法，好在这并不会造成数据丢失，just a tradoff！</li>
</ol>


<h3>References</h3>

<ol>
<li><a href="https://en.wikipedia.org/wiki/Vector_clock">Vector Clock In Wikipedia</a></li>
<li><a href="https://www.amazon.com/Distributed-Systems-Algorithmic-Approach-Information/dp/1466552972">《Distributed Systems An Algorithmic Approach Second Edition》 6.3 Vector Clock</a></li>
<li><a href="http://basho.com/posts/technical/why-vector-clocks-are-hard/">Why Vector Clocks Are Hard</a></li>
</ol>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2017-06-05T00:59:00+08:00" pubdate data-updated="true">Jun 5<span>th</span>, 2017</time></div>
	<div class="tags">


	<a class='category' href='/tags/distribute/'>distribute</a>, <a class='category' href='/tags/system/'>system</a>


</div>
	
	<div class="comments"><a href="/2017/06/05/vector-clock/#duoshuo">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/2017/06/03/Time-Clocks-and-the-Ordering-of-Events-in-a-Distributed-System/">
		
			《Time, Clocks, and the Ordering of Events in a Distributed System》summary</a>
	</h2>
	<div class="entry-content">
		<h1>Summary</h1>

<h3>Happend before</h3>

<p>用→来表示<code>hanppend before</code>，对于任意event a, b 有：</p>

<ol>
<li>如果a和b属于同一个process，并且a comes before b, 则 a → b</li>
<li>如果a是某个process发送信息的event，b是另一个process接收该信息的event，那么 a → b</li>
<li>如果 a → b并且 b → c，那么 a → c</li>
</ol>


<p>以上本质是基于一个因果关系(causality)来定义的<code>hanppend before</code></p>

<p><code>concurrence</code>意味着a → b不成立并且b→a也不成立，即a,b之间缺少因果关系</p>

<p>b →  c 并且 a  →  c, 但是a,b并不能推导出因果关系，因此<code>happend before</code>是partial order.
同时由于a → a不成立，所以<code>happend before</code>是反自反(irreflexive)的partial order</p>

<h3>logical clocks</h3>

<p>定义Ci(b)为event b在process i 上发生时的clock。</p>

<p>对于任意的events a,b：</p>

<blockquote><p>如果a → b,则C(a)&lt; C(b)</p></blockquote>

<p>显而易见：</p>

<ol>
<li>如果a,b同属于process Pi, 并且 a comes before b, 则C(a) &lt; C(b)</li>
<li>如果a是Pi上发送信息的event，b是Pj上接收该信息的event，那么Ci(a) &lt; Cj(b)</li>
</ol>


<p>具体实现：</p>

<ol>
<li>对于任意Pi在两个successive event之间会增加Ci, Ci += 1</li>
<li>以下</li>
<li>a. 如果a是Pi上发送信息的event，信息m包含一个时间戳Tm = Ci(a)</li>
<li>b. 当Pj收到信息m，设置Cj = max(Cj, Tm) + 1</li>
</ol>


<p>Logical Clock 的缺点：a, b可能同时发生，C(a) &lt; C(b)并不能推断出a → b</p>

<h3>total ordering</h3>

<blockquote><p>In mathematics, a linear order, total order, simple order, or (non-strict) ordering is a binary relation on some set X, which is antisymmetric, transitive, and total. A set paired with a total order is called a totally ordered set, a linearly ordered set, a simply ordered set, or a chain. &#8212;- from wikipedia</p></blockquote>

<p>定义关系=>如下：</p>

<blockquote><p>如果a属于Pi，b属于Pj，a => b当且仅当要么Ci(a) &lt; Ci(b)要么Ci(a) = Ci(b) 并且Pi &lt; Pj</p></blockquote>

<p>Pi &lt; Pj可以是process name 字典序或者数字标示的顺序。</p>

<p>total ordering强调对于任意两个元素都有可比性</p>

<p>paper中举例使用no-fault-tolent total ordering解决分布式情况下mutual exclusion的问题</p>

<p>值得特别强调的一点，这里的total ordering和<code>hanppend before</code>没有关系，但是total ordering的意义在于可以用在例如mutual exclusion场景，用顺序来保证fairness（一般的mutual exclusion的关系是FIFO来保证fairness的）</p>

<h3>Anomalous Behavior</h3>

<p>例如：</p>

<ol>
<li>event a : P 发送消息到R</li>
<li>event b :  P发送消息到Q，Q将消息转发给R</li>
</ol>


<p>对于P而言 a→b,但是由于网络延迟R就不一定这么认为了。</p>

<p>解决方法有两种：</p>

<ol>
<li>发送的消息中带上logical clock</li>
<li>利用Physical Clock</li>
</ol>


<h3>Physical Clocks</h3>

<p>大概介绍了什么样（主要指同步）的physical clock可以用来解决上述的问题。</p>

<h3>References</h3>

<ol>
<li><a href="https://en.wikipedia.org/wiki/Lamport_timestamps">wikipedia</a></li>
<li><a href="https://www.amazon.com/Distributed-Systems-Algorithmic-Approach-Information/dp/1466552972">《Distributed Systems An Algorithmic Approach Second Edition》 6.2 Logical Clock</a></li>
<li><a href="https://www.amazon.com/Distributed-Systems-Algorithmic-Approach-Information/dp/1466552972">《Distributed Systems An Algorithmic Approach Second Edition》 7.2 Solutions On Message-Passing Systems</a></li>
</ol>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2017-06-03T23:59:00+08:00" pubdate data-updated="true">Jun 3<span>rd</span>, 2017</time></div>
	<div class="tags">


	<a class='category' href='/tags/distribute/'>distribute</a>, <a class='category' href='/tags/system/'>system</a>


</div>
	
	<div class="comments"><a href="/2017/06/03/Time-Clocks-and-the-Ordering-of-Events-in-a-Distributed-System/#duoshuo">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/2016/09/10/leveldb-read/">
		
			Leveldb源码笔记之读操作</a>
	</h2>
	<div class="entry-content">
		<h3>key逻辑分类</h3>

<p>根据我们之前文章的描述，leveldb的数据存储可能存在在内存的memtable中，或者磁盘的sstalbe中，但是key的实际存储格式会略微有差异，代码里按照存储的位置，划分为以下几种类型：</p>

<blockquote><p><strong>memtable</strong>: 逻辑上称为memtable_key</p>

<p><strong>sstalbe</strong>: 逻辑上称为internal_key</p>

<p><strong>key</strong>: 用户提供的key，我们称之为user_key</p></blockquote>

<p>当用户去查询某个key时，leveldb会先利用key构建起Lookupkey类</p>

<p>Lookupkey类内部的完整数据即memtable_key，可以方便的利用成员函数截取memtable_key,internal_key,user_key以方便去memtalble和sstable中查询</p>

<p>事实上LookupKey是由 key， sequence number组成的，如之前文章提到:</p>

<ul>
<li>如果普通Get()操作，sequence number 为 last sequence number</li>
<li>如果是使用的snapshot, sequence number 为 snapshot sequence number</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// dbformat.h</span>
</span><span class='line'><span class="c1">// lookup key format:</span>
</span><span class='line'><span class="c1">// start_       kstart_                                         end_</span>
</span><span class='line'><span class="c1">//   |             |                                             |</span>
</span><span class='line'><span class="c1">//   |             |&lt;--user_key--&gt;|                              |</span>
</span><span class='line'><span class="c1">//   |             |&lt;---------------internal_key----------------&gt;|</span>
</span><span class='line'><span class="c1">//   |&lt;---------------------memtable_key------------------------&gt;|</span>
</span><span class='line'><span class="c1">//   -------------------------------------------------------------</span>
</span><span class='line'><span class="c1">//   |  1--5 byte  | klenght byte |           8 byte             |</span>
</span><span class='line'><span class="c1">//   -------------------------------------------------------------</span>
</span><span class='line'><span class="c1">//   | klenght + 8 |   raw key    | pack(sequence number, type)) |</span>
</span><span class='line'><span class="c1">//   -------------------------------------------------------------</span>
</span><span class='line'><span class="c1">// A helper class useful for DBImpl::Get()</span>
</span><span class='line'><span class="k">class</span> <span class="nc">LookupKey</span> <span class="p">{</span>
</span><span class='line'> <span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="c1">// Initialize *this for looking up user_key at a snapshot with</span>
</span><span class='line'>  <span class="c1">// the specified sequence number.</span>
</span><span class='line'>  <span class="n">LookupKey</span><span class="p">(</span><span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">user_key</span><span class="p">,</span> <span class="n">SequenceNumber</span> <span class="n">sequence</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="o">~</span><span class="n">LookupKey</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Return a key suitable for lookup in a MemTable.</span>
</span><span class='line'>  <span class="n">Slice</span> <span class="n">memtable_key</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Slice</span><span class="p">(</span><span class="n">start_</span><span class="p">,</span> <span class="n">end_</span> <span class="o">-</span> <span class="n">start_</span><span class="p">);</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Return an internal key (suitable for passing to an internal iterator)</span>
</span><span class='line'>  <span class="n">Slice</span> <span class="n">internal_key</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Slice</span><span class="p">(</span><span class="n">kstart_</span><span class="p">,</span> <span class="n">end_</span> <span class="o">-</span> <span class="n">kstart_</span><span class="p">);</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Return the user key</span>
</span><span class='line'>  <span class="n">Slice</span> <span class="n">user_key</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Slice</span><span class="p">(</span><span class="n">kstart_</span><span class="p">,</span> <span class="n">end_</span> <span class="o">-</span> <span class="n">kstart_</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'> <span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">start_</span><span class="p">;</span>
</span><span class='line'>  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">kstart_</span><span class="p">;</span>
</span><span class='line'>  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">end_</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">char</span> <span class="n">space_</span><span class="p">[</span><span class="mi">200</span><span class="p">];</span>      <span class="c1">// Avoid allocation for short keys</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// No copying allowed</span>
</span><span class='line'>  <span class="n">LookupKey</span><span class="p">(</span><span class="k">const</span> <span class="n">LookupKey</span><span class="o">&amp;</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">LookupKey</span><span class="o">&amp;</span><span class="p">);</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>如图:
<img src="/images/blog_images/leveldb/leveldb-keys.png" alt="" /></p>

<h3>读操作</h3>

<p>图示Get()操作的基本逻辑如下：
<img src="/images/blog_images/leveldb/leveldb-read.png" alt="" />
以上我们是假设sstable没有filter的情况下的操作逻辑</p>

<h3>cache</h3>

<p>无论是table cache，还是block cache，都是使用了相同的数据结构LRUCache来实现的，区别只在于内部存储的数据不同。</p>

<p>LRUCache是通过k/v方式存储的，对于：</p>

<p><strong>TableCache</strong>:</p>

<ul>
<li>key: 其实就是file number</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// table_cache.cc</span>
</span><span class='line'><span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">file_number</span><span class="p">)];</span>
</span><span class='line'><span class="n">EncodeFixed64</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">file_number</span><span class="p">);</span>
</span><span class='line'><span class="n">Slice</span> <span class="n">key</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>value: TableAndFile， 其实主要是sstable index block里的数据</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// table_cache.cc</span>
</span><span class='line'><span class="k">struct</span> <span class="n">TableAndFile</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">RandomAccessFile</span><span class="o">*</span> <span class="n">file</span><span class="p">;</span>
</span><span class='line'>  <span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// table.cc</span>
</span><span class='line'><span class="c1">// Table里的主要数据即下述</span>
</span><span class='line'><span class="k">struct</span> <span class="n">Table</span><span class="o">::</span><span class="n">Rep</span> <span class="p">{</span>
</span><span class='line'>    <span class="o">~</span><span class="n">Rep</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">delete</span> <span class="n">filter</span><span class="p">;</span>
</span><span class='line'>      <span class="k">delete</span> <span class="p">[]</span> <span class="n">filter_data</span><span class="p">;</span>
</span><span class='line'>      <span class="k">delete</span> <span class="n">index_block</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Options</span> <span class="n">options</span><span class="p">;</span>
</span><span class='line'>    <span class="n">Status</span> <span class="n">status</span><span class="p">;</span>
</span><span class='line'>    <span class="n">RandomAccessFile</span><span class="o">*</span> <span class="n">file</span><span class="p">;</span>
</span><span class='line'>    <span class="n">uint64_t</span> <span class="n">cache_id</span><span class="p">;</span>
</span><span class='line'>    <span class="n">FilterBlockReader</span><span class="o">*</span> <span class="n">filter</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filter_data</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">BlockHandle</span> <span class="n">metaindex_handle</span><span class="p">;</span>  <span class="c1">// Handle to metaindex_block: saved from footer</span>
</span><span class='line'>    <span class="n">Block</span><span class="o">*</span> <span class="n">index_block</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>BlockCache</strong>:</p>

<ul>
<li>key: 其实是 cache_id 和 block 在sstable中的offset的组合</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// table.cc</span>
</span><span class='line'><span class="kt">char</span> <span class="n">cache_key_buffer</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
</span><span class='line'><span class="c1">// 构造block_cache 的key</span>
</span><span class='line'><span class="n">EncodeFixed64</span><span class="p">(</span><span class="n">cache_key_buffer</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">rep_</span><span class="o">-&gt;</span><span class="n">cache_id</span><span class="p">);</span>
</span><span class='line'><span class="n">EncodeFixed64</span><span class="p">(</span><span class="n">cache_key_buffer</span><span class="o">+</span><span class="mi">8</span><span class="p">,</span> <span class="n">handle</span><span class="p">.</span><span class="n">offset</span><span class="p">());</span>
</span><span class='line'><span class="n">Slice</span> <span class="n">key</span><span class="p">(</span><span class="n">cache_key_buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cache_key_buffer</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>value: data block 内容</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// block.h</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Block</span> <span class="p">{</span>
</span><span class='line'> <span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="c1">// Initialize the block with the specified contents.</span>
</span><span class='line'>  <span class="k">explicit</span> <span class="n">Block</span><span class="p">(</span><span class="k">const</span> <span class="n">BlockContents</span><span class="o">&amp;</span> <span class="n">contents</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="o">~</span><span class="n">Block</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">size_t</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">size_</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>  <span class="n">Iterator</span><span class="o">*</span> <span class="n">NewIterator</span><span class="p">(</span><span class="k">const</span> <span class="n">Comparator</span><span class="o">*</span> <span class="n">comparator</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'> <span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="n">uint32_t</span> <span class="n">NumRestarts</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">data_</span><span class="p">;</span>
</span><span class='line'>  <span class="n">size_t</span> <span class="n">size_</span><span class="p">;</span>
</span><span class='line'>  <span class="n">uint32_t</span> <span class="n">restart_offset_</span><span class="p">;</span>     <span class="c1">// Offset in data_ of restart array</span>
</span><span class='line'>  <span class="kt">bool</span> <span class="n">owned_</span><span class="p">;</span>                  <span class="c1">// Block owns data_[]</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// No copying allowed</span>
</span><span class='line'>  <span class="n">Block</span><span class="p">(</span><span class="k">const</span> <span class="n">Block</span><span class="o">&amp;</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Block</span><span class="o">&amp;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">class</span> <span class="nc">Iter</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<h4>cache 逻辑结构图示</h4>

<p><img src="/images/blog_images/leveldb/leveldb-cache.png" alt="" /></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2016-09-10T22:07:00+08:00" pubdate data-updated="true">Sep 10<span>th</span>, 2016</time></div>
	<div class="tags">


	<a class='category' href='/tags/distribute/'>distribute</a>, <a class='category' href='/tags/leveldb/'>leveldb</a>, <a class='category' href='/tags/system/'>system</a>


</div>
	
	<div class="comments"><a href="/2016/09/10/leveldb-read/#duoshuo">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/2016/09/06/leveldb-compact/">
		
			leveldb源码笔记之Compact</a>
	</h2>
	<div class="entry-content">
		<h3>简介</h3>

<p>leveldb中只有minor compaction 和 major compaction两种</p>

<ul>
<li>代码中通过调用<code>DBImpl::MaybeScheduleCompaction()</code>来触发两种compaction</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// db_impl.cc</span>
</span><span class='line'><span class="kt">void</span> <span class="n">DBImpl</span><span class="o">::</span><span class="n">MaybeScheduleCompaction</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">mutex_</span><span class="p">.</span><span class="n">AssertHeld</span><span class="p">();</span>
</span><span class='line'>  <span class="c1">// 确保只有一个后台线程在做compact</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">bg_compaction_scheduled_</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// Already scheduled</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">shutting_down_</span><span class="p">.</span><span class="n">Acquire_Load</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// DB is being deleted; no more background compactions</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bg_error_</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// Already got an error; no more changes</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">imm_</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
</span><span class='line'>             <span class="n">manual_compaction_</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
</span><span class='line'>             <span class="o">!</span><span class="n">versions_</span><span class="o">-&gt;</span><span class="n">NeedsCompaction</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// No work to be done</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">bg_compaction_scheduled_</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">// 启动compact线程,主要逻辑是通过DBImpl::BackgroundCompaction()实现</span>
</span><span class='line'>    <span class="n">env_</span><span class="o">-&gt;</span><span class="n">Schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">DBImpl</span><span class="o">::</span><span class="n">BGWork</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>调用时机:</p>

<ul>
<li>1.每次写入前，需要确保空间充足，如果空间不足，尝试将memtable转换为immutable-memtable，之后调用<code>DBImpl::MaybeScheduleCompaction()</code></li>
<li>2.每次重启db，binlog recover结束后，会触发调用<code>DBImpl::MaybeScheduleCompaction()</code></li>
<li>3.每次读取一条记录结束时会触发调用<code>DBImpl::MaybeScheduleCompaction()</code></li>
</ul>


<h3>minor compaction:</h3>

<h4>方式：</h4>

<ul>
<li>将immutalbe-memtable dump到磁盘，形成sstable</li>
<li>sstable一般位于level-0,如果sstable的key范围和当前level没有重叠会尝试下移，最多不会超过<code>config::kMaxMemCompactLevel(默认为2)</code></li>
</ul>


<h4>触发时机:</h4>

<ul>
<li>每次调用BackGroudCompaction如果存在immutalbe-memtable都会触发将其dump到磁盘</li>
</ul>


<h3>major compaction</h3>

<h4>方式：</h4>

<ul>
<li>将level-n的sstable 与 level-(n+1)中与之存在key范围重叠的sstable多路归并，生成level-(n+1)的sstable</li>
<li>如果是level-0,则由于level-0中sstable之间key有重叠，所以level-0参与compact的sstable可能不止一个</li>
</ul>


<h4>触发时机:</h4>

<p>第一种是size触发类型(优先)：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// version_set.cc</span>
</span><span class='line'><span class="kt">void</span> <span class="n">VersionSet</span><span class="o">::</span><span class="n">Finalize</span><span class="p">(</span><span class="n">Version</span><span class="o">*</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// Precomputed best level for next compaction</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">best_level</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">double</span> <span class="n">best_score</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">level</span> <span class="o">&lt;</span> <span class="n">config</span><span class="o">::</span><span class="n">kNumLevels</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">level</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">double</span> <span class="n">score</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">// We treat level-0 specially by bounding the number of files</span>
</span><span class='line'>      <span class="c1">// instead of number of bytes for two reasons:</span>
</span><span class='line'>      <span class="c1">//</span>
</span><span class='line'>      <span class="c1">// 对于较大的write buffer, 不过多的进行levle-0的compactions是好的</span>
</span><span class='line'>      <span class="c1">// (1) With larger write-buffer sizes, it is nice not to do too</span>
</span><span class='line'>      <span class="c1">// many level-0 compactions.</span>
</span><span class='line'>      <span class="c1">//</span>
</span><span class='line'>      <span class="c1">// 因为每次读操作都会触发level-0的归并，因此当个别的文件size很小的时候</span>
</span><span class='line'>      <span class="c1">// 我们期望避免level-0有太多文件存在</span>
</span><span class='line'>      <span class="c1">// (2) The files in level-0 are merged on every read and</span>
</span><span class='line'>      <span class="c1">// therefore we wish to avoid too many files when the individual</span>
</span><span class='line'>      <span class="c1">// file size is small (perhaps because of a small write-buffer</span>
</span><span class='line'>      <span class="c1">// setting, or very high compression ratios, or lots of</span>
</span><span class='line'>      <span class="c1">// overwrites/deletions).</span>
</span><span class='line'>      <span class="n">score</span> <span class="o">=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">files_</span><span class="p">[</span><span class="n">level</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span>
</span><span class='line'>          <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">config</span><span class="o">::</span><span class="n">kL0_CompactionTrigger</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">// Compute the ratio of current size to size limit.</span>
</span><span class='line'>      <span class="k">const</span> <span class="n">uint64_t</span> <span class="n">level_bytes</span> <span class="o">=</span> <span class="n">TotalFileSize</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">files_</span><span class="p">[</span><span class="n">level</span><span class="p">]);</span>
</span><span class='line'>      <span class="n">score</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">level_bytes</span><span class="p">)</span> <span class="o">/</span> <span class="n">MaxBytesForLevel</span><span class="p">(</span><span class="n">level</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">score</span> <span class="o">&gt;</span> <span class="n">best_score</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">best_level</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span>
</span><span class='line'>      <span class="n">best_score</span> <span class="o">=</span> <span class="n">score</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">v</span><span class="o">-&gt;</span><span class="n">compaction_level_</span> <span class="o">=</span> <span class="n">best_level</span><span class="p">;</span>
</span><span class='line'>  <span class="n">v</span><span class="o">-&gt;</span><span class="n">compaction_score_</span> <span class="o">=</span> <span class="n">best_score</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>对于level-0:</p>

<ul>
<li>score = level-0文件数/config::kL0_CompactionTrigger(默认为4)</li>
</ul>
</li>
<li><p>对于level-n(n>0)：</p>

<ul>
<li>score = 当前level的字节数 / (10<sup>n</sup> * 2<sup>20)</sup>  2<sup>20</sup> 即1MB</li>
</ul>
</li>
<li><p>score >= 1,当前level就会被标识起来，等待触发 compaction</p></li>
</ul>


<p>第二种是seek触发:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// version_edit.h</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 记录了文件编号， 文件大小，最小key，最大key</span>
</span><span class='line'><span class="c1">// sstable文件的命名就是按照file number + 特定后缀完成的</span>
</span><span class='line'><span class="k">struct</span> <span class="n">FileMetaData</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">refs</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">allowed_seeks</span><span class="p">;</span>          <span class="c1">// Seeks allowed until compaction</span>
</span><span class='line'>  <span class="n">uint64_t</span> <span class="n">number</span><span class="p">;</span>
</span><span class='line'>  <span class="n">uint64_t</span> <span class="n">file_size</span><span class="p">;</span>         <span class="c1">// File size in bytes</span>
</span><span class='line'>  <span class="n">InternalKey</span> <span class="n">smallest</span><span class="p">;</span>       <span class="c1">// Smallest internal key served by table</span>
</span><span class='line'>  <span class="n">InternalKey</span> <span class="n">largest</span><span class="p">;</span>        <span class="c1">// Largest internal key served by table</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">FileMetaData</span><span class="p">()</span> <span class="o">:</span> <span class="n">refs</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">allowed_seeks</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">),</span> <span class="n">file_size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// version_set.cc</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Apply all of the edits in *edit to the current state.</span>
</span><span class='line'><span class="kt">void</span> <span class="n">Apply</span><span class="p">(</span><span class="n">VersionEdit</span><span class="o">*</span> <span class="n">edit</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">edit</span><span class="o">-&gt;</span><span class="n">new_files_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">const</span> <span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="n">edit</span><span class="o">-&gt;</span><span class="n">new_files_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">;</span>
</span><span class='line'>    <span class="n">FileMetaData</span><span class="o">*</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileMetaData</span><span class="p">(</span><span class="n">edit</span><span class="o">-&gt;</span><span class="n">new_files_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="p">);</span>
</span><span class='line'>    <span class="n">f</span><span class="o">-&gt;</span><span class="n">refs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">// We arrange to automatically compact this file after</span>
</span><span class='line'>    <span class="c1">// a certain number of seeks.  Let&#39;s assume:</span>
</span><span class='line'>    <span class="c1">//   (1) One seek costs 10ms</span>
</span><span class='line'>    <span class="c1">//   (2) Writing or reading 1MB costs 10ms (100MB/s)</span>
</span><span class='line'>    <span class="c1">//   (3) A compaction of 1MB does 25MB of IO:</span>
</span><span class='line'>    <span class="c1">//        1MB read from this level</span>
</span><span class='line'>    <span class="c1">//        10-12MB read from next level(boundaries may be misaligned)</span>
</span><span class='line'>    <span class="c1">//        10-12MB written to next level</span>
</span><span class='line'>    <span class="c1">// This implies that 25 seeks cost the same as the compaction</span>
</span><span class='line'>    <span class="c1">// of 1MB of data.  I.e., one seek costs approximately the</span>
</span><span class='line'>    <span class="c1">// same as the compaction of 40KB of data.  We are a little</span>
</span><span class='line'>    <span class="c1">// conservative and allow approximately one seek for every 16KB</span>
</span><span class='line'>    <span class="c1">// of data before triggering a compaction.</span>
</span><span class='line'>    <span class="c1">// 1次seek相当与compact 40kb的data,</span>
</span><span class='line'>    <span class="c1">// 那么n次seek大概和compact一个sstable相当(n = sstable_size / 40kb)</span>
</span><span class='line'>    <span class="c1">// 保守点，这里搞了个16kb</span>
</span><span class='line'>    <span class="n">f</span><span class="o">-&gt;</span><span class="n">allowed_seeks</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">file_size</span> <span class="o">/</span> <span class="mi">16384</span><span class="p">);</span>  <span class="c1">// 2^14 == 16384 == 16kb</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">allowed_seeks</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">)</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">allowed_seeks</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>当一个新的sstable建立时，会有一个allowed_seeks的初值：

<ul>
<li>作者认为1次sstable的seek（<code>此处的seek就是指去sstable里查找指定key</code>），相当于compact 40kb的数据，那么 sstable size / 40kb  次的seek操作，大概和compact 一个 sstable相当</li>
<li>保守的做法，allowed_seeks的初值为file_size/16kb</li>
<li>如果allowed_seeks小于100，令其为100</li>
</ul>
</li>
<li>每当Get操作触发磁盘读，即sstable被读取，该数值就会减一；如果有多个sstable被读取，则仅首个被读取的sstable的sllowed_seeks减一</li>
<li>allowed_seeks == 0 时，该sstable以及其所处level会被标识起来，等待触发 compaction</li>
</ul>


<h4>sstable选择：</h4>

<ul>
<li><p>针对size触发类型，默认从当前level的首个sstable开始执行</p></li>
<li><p>seek触发相对简单，sstable已经选择好了</p></li>
<li><p>对于level-0,需要将与选中的sstable存在key重叠的sstable也包含进此次compact</p></li>
<li><p>对于level-(n+1)，需要将与level-n中选中的sstable存在key重叠的sstable包含进此次compact</p>

<blockquote><p>由于level-(n+1)多个sstable的参与扩展了整个compact的key的范围, 我们可以使用该key范围将level-n中更多的sstable包含进此次compact
前提是保证level-n更多sstable的参与不会导致level-(n+1)的sstable数量再次增长.
同时，参与整个compaction的字节数不超过kExpandedCompactionByteSizeLimit = 25 * kTargetFileSize = 25 * 2MB;</p></blockquote></li>
<li><p>为了保持公平，保证某个level中每个sstable都有机会参与compact:</p>

<ul>
<li>存储当前level首次compact的sstable(s)的largest key，存入compact_point_[level]</li>
<li>当前level如果再次被size触发进行compact时，选择首个largest key大于compact_point_[level] sstable进行compact</li>
</ul>
</li>
</ul>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2016-09-06T14:55:00+08:00" pubdate data-updated="true">Sep 6<span>th</span>, 2016</time></div>
	<div class="tags">


	<a class='category' href='/tags/distribute/'>distribute</a>, <a class='category' href='/tags/leveldb/'>leveldb</a>


</div>
	
	<div class="comments"><a href="/2016/09/06/leveldb-compact/#duoshuo">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/2016/08/24/mvcc-and-manifest/">
		
			leveldb源码笔记之MVCC && Manifest</a>
	</h2>
	<div class="entry-content">
		<h3>MVCC</h3>

<p><strong>问题</strong>:
针对同一条记录，如果读和写在同一时间发生时，reader可能会读取到不一致或者写了一半的数据</p>

<p><strong>常见解决方案</strong></p>

<blockquote><p>悲观锁：</p>

<blockquote><p>最简单的方式,即通过锁来控制并发，但是效率非常的低,增加的产生死锁的机会</p></blockquote>

<p>乐观锁：</p>

<blockquote><p>它假设多用户并发的事物在处理时不会彼此互相影响，各食物能够在不产生锁的的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚;这样做不会有锁竞争更不会产生思索，但如果数据竞争的概率较高，效率也会受影响</p></blockquote>

<p>MVCC &#8211; Multiversion concurrency control:</p>

<blockquote><p>每一个执行操作的用户，看到的都是数据库特定时刻的的快照(snapshot), writer的任何未完成的修改都不会被其他的用户所看到;当对数据进行更新的时候并是不直接覆盖，而是先进行标记, 然后在其他地方添加新的数据，从而形成一个新版本, 此时再来读取的reader看到的就是最新的版本了。所以这种处理策略是维护了多个版本的数据的,但只有一个是最新的。</p></blockquote></blockquote>

<h3>Key/Value</h3>

<p>如<a href="http://1feng.github.io/2016/08/18/leveldb-write/">前文</a>所述，leveldb中写入一条记录，仅仅是先写入binlog，然后写入memtable</p>

<ul>
<li><p><strong>binlog</strong>: binlog的写入只需要append，无需并发控制</p></li>
<li><p><strong>memtable</strong>: memtable是使用Memory Barriers技术实现的无锁的skiplist</p></li>
<li><p><strong>更新</strong>: 真正写入memtable中参与skiplist排序的key其实是包含sequence number的，所以更新操作其实只是写入了一条新的k/v记录, 真正的更新由compact完成</p></li>
<li><p><strong>删除</strong>: 如<a href="http://1feng.github.io/2016/08/18/leveldb-write/">前文</a>提到，删除一条Key时，仅仅是将type标记为kTypeDeletion，写入(同上述写入逻辑)了一条新的记录，并没有真正删除,真正的删除也是由compact完成的</p></li>
</ul>


<h4>Sequence Number</h4>

<ul>
<li><p>sequence number 是一个由VersionSet直接持有的全局的编号，每次写入（<code>注意批量写入时sequence number是相同的</code>），就会递增</p></li>
<li><p>根据我们之前对写入操作的分析，我们可以看到，当插入一条key的时候，实际参与排序，存储的是key和sequence number以及type组成的
InternalKey</p></li>
<li><p>当我们进行Get操作时，我们只需要找到目标key，同时其sequence number &lt;= specific sequence number</p>

<ul>
<li>普通的读取，sepcific sequence number == last sequence number</li>
<li>snapshot读取，sepcific sequenc number == snapshot sequence number</li>
</ul>
</li>
</ul>


<h4>Snapshot</h4>

<p>snapshot 其实就是一个sequence number，获取snapshot，即获取当前的last sequence number</p>

<p>例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'>  <span class="n">string</span> <span class="n">key</span> <span class="o">=</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
</span><span class='line'>  <span class="n">string</span> <span class="n">value</span> <span class="o">=</span> <span class="sc">&#39;b&#39;</span><span class="p">;</span>
</span><span class='line'>  <span class="n">leveldb</span><span class="o">::</span><span class="n">Status</span> <span class="n">s</span> <span class="o">=</span> <span class="n">db</span><span class="o">-&gt;</span><span class="n">Put</span><span class="p">(</span><span class="n">leveldb</span><span class="o">::</span><span class="n">WriteOptions</span><span class="p">(),</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
</span><span class='line'>  <span class="n">assert</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span>
</span><span class='line'>  <span class="n">leveldb</span><span class="o">::</span><span class="n">ReadOptions</span> <span class="n">options</span><span class="p">;</span>
</span><span class='line'>  <span class="n">options</span><span class="p">.</span><span class="n">snapshot</span> <span class="o">=</span> <span class="n">db</span><span class="o">-&gt;</span><span class="n">GetSnapshot</span><span class="p">();</span>
</span><span class='line'>  <span class="n">string</span> <span class="n">value</span> <span class="o">=</span> <span class="sc">&#39;c&#39;</span><span class="p">;</span>
</span><span class='line'>  <span class="n">leveldb</span><span class="o">::</span><span class="n">Status</span> <span class="n">s</span> <span class="o">=</span> <span class="n">db</span><span class="o">-&gt;</span><span class="n">Put</span><span class="p">(</span><span class="n">leveldb</span><span class="o">::</span><span class="n">WriteOptions</span><span class="p">(),</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
</span><span class='line'>  <span class="n">assert</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span>
</span><span class='line'>  <span class="c1">// ...</span>
</span><span class='line'>  <span class="c1">// ...</span>
</span><span class='line'>  <span class="n">value</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span><span class='line'>  <span class="n">s</span> <span class="o">=</span> <span class="n">db</span><span class="o">-&gt;</span><span class="n">Get</span><span class="p">(</span><span class="n">leveldb</span><span class="o">::</span><span class="n">ReadOptions</span><span class="p">(),</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>   <span class="c1">// value == &#39;c&#39;</span>
</span><span class='line'>  <span class="n">assert</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span>
</span><span class='line'>  <span class="n">s</span> <span class="o">=</span> <span class="n">db</span><span class="o">-&gt;</span><span class="n">Get</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>   <span class="c1">// value == &#39;b&#39;</span>
</span><span class='line'>  <span class="n">assert</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>我们知道在sstable compact的时候，才会执行真正的删除或覆盖，而覆盖则是如果发现两条相同的记录
会丢弃旧的(sequence number较小)一条，但是这同时会破坏掉snapshot</li>
<li>那么 key = &#8216;a&#8217;, value = &#8216;b&#8217;是如何避免compact时被丢弃掉的呢？

<ul>
<li>db在内存中记录了当前用户持有的所有snapshot</li>
<li>smallest snapshot = has snapshot ? oldest snapshot : last sequence number</li>
<li>当进行compact时，如果发现两条相同的记录，只有当两条记录的sequence number都小于 smallest snapshot 时才丢弃掉其中sequence number较小的一条</li>
</ul>
</li>
</ul>


<h3>Sstable</h3>

<p>sstable级别的MVCC是利用Version和VersionEdit实现的：</p>

<ul>
<li>只有一个current version，持有了最新的sstable集合</li>
<li>VersionEdit代表了一次current version的更新, 新增了那些sstable，哪些sstable已经没用了等</li>
</ul>


<p><img src="/images/blog_images/leveldb/mvcc.png" alt="" /></p>

<h3>Mainifest</h3>

<p>每次current version 更新的数据(即新产生的VersionEdit)都写入mainifest文件，以便重启时recover</p>

<p><img src="/images/blog_images/leveldb/write_a_manifest.png" alt="" /></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2016-08-24T15:51:00+08:00" pubdate data-updated="true">Aug 24<span>th</span>, 2016</time></div>
	<div class="tags">


	<a class='category' href='/tags/distribute/'>distribute</a>, <a class='category' href='/tags/leveldb/'>leveldb</a>, <a class='category' href='/tags/system/'>system</a>


</div>
	
	<div class="comments"><a href="/2016/08/24/mvcc-and-manifest/#duoshuo">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/2016/08/22/sstable-summary/">
		
			Leveldb源码笔记之sstable</a>
	</h2>
	<div class="entry-content">
		<h3>整体看下sstable的组要组成，如下：</h3>

<p><img src="/images/blog_images/leveldb/sstable.png" alt="" /></p>

<h3>sstalbe 生成细节</h3>

<blockquote><p>sstable 生成时机:</p>

<p>minor compaction</p>

<blockquote><p>immutable-memtable 中的key/value dump到磁盘，生成sstable</p></blockquote>

<p>major compaction</p>

<blockquote><p>sstable compact（level-n sstable(s)与level-n+1 sstables多路归并）生成level-n+1的sstable</p></blockquote></blockquote>

<h4>首先是写入data block:</h4>

<p><img src="/images/blog_images/leveldb/write_a_data_block.png" alt="" /></p>

<h4>data block都写入完成后，接下来是meta block:</h4>

<p><img src="/images/blog_images/leveldb/write_a_meta_block.png" alt="" /></p>

<h4>然后是data/meta block索引信息data/meta index block写入:</h4>

<p><img src="/images/blog_images/leveldb/write_a_index_block.png" alt="" /></p>

<h4>最后将index block的索引信息写入Footer</h4>

<p><img src="/images/blog_images/leveldb/write_a_footer.png" alt="" /></p>

<h4>一个完整的sstable形成!</h4>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2016-08-22T11:19:00+08:00" pubdate data-updated="true">Aug 22<span>nd</span>, 2016</time></div>
	<div class="tags">


	<a class='category' href='/tags/distribute/'>distribute</a>, <a class='category' href='/tags/leveldb/'>leveldb</a>, <a class='category' href='/tags/system/'>system</a>


</div>
	
	<div class="comments"><a href="/2016/08/22/sstable-summary/#duoshuo">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/2016/08/18/leveldb-write/">
		
			Leveldb源码笔记之写入操作</a>
	</h2>
	<div class="entry-content">
		<h4>插入一条K/V记录</h4>

<p><img src="/images/blog_images/leveldb/writer.png" alt="" /></p>

<h4>持有Writer的线程进入Writers队列,细节如下：</h4>

<p><img src="/images/blog_images/leveldb/writers_queue.png" alt="" /></p>

<h4>MakeRoomForWrite的流程图：</h4>

<p><img src="/images/blog_images/leveldb/make_room_for_write.png" alt="" /></p>

<h4>记录会首先写入磁盘上的binlog，避免程序crash时内存数据丢失：</h4>

<p><img src="/images/blog_images/leveldb/write_to_binlog.png" alt="" /></p>

<blockquote><p>此处我们做了一个极度夸张的假设来做演示:两条记录的大小超出一个block的大小, 以至于被一切为三</p></blockquote>

<h4>K/V记录插入内存中的Memtable:</h4>

<p><img src="/images/blog_images/leveldb/write_to_memtable.png" alt="" /></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2016-08-18T15:03:00+08:00" pubdate data-updated="true">Aug 18<span>th</span>, 2016</time></div>
	<div class="tags">


	<a class='category' href='/tags/distribute/'>distribute</a>, <a class='category' href='/tags/leveldb/'>leveldb</a>


</div>
	
	<div class="comments"><a href="/2016/08/18/leveldb-write/#duoshuo">Comments</a></div>
	
</div>
</article>

<nav id="pagenavi">
    
        <a href="/" class="prev">Prev</a>
    
    
        <a href="/blog/page/3/" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav></div>
	<footer id="footer" class="inner">Copyright &copy; 2021

    Travis Swicegood

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->
<!--

 -->

	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-50190414-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>




</body>
</html>