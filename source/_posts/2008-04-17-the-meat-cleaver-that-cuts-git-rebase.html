--- 
layout: post
title: "The meat cleaver that cuts: git rebase"
---
<p>While I've been writing my Git book, I keep trying to pick up new tricks and figure out places to use them.  A came across <a href="http://blog.madism.org/index.php/2007/09/09/138-git-awsome-ness-git-rebase-interactive">a post on <code>git rebase --interactive</code></a> and knew I had to find an opportunity to play with this.  This morning, that opportunity came.</p>

<p>I've been working on some performance enhancement at work this week.  I use Git locally for all of my development, then push back to our central Subversion repo once my changes are done and approved for the main repository.  Timing for the changes I made earlier in the week was bad, so I was going to hang on to them for a week and push them when our engineering/QA department can absorb them more easily.</p>

<p>... the observant reader should be picking up on the past-tense here ...</p>

<p>So as part of my changes I created a Registry to share a single instance of an object around instead of going the Singleton route or putting the data in the global scope.  Pretty useful all round, but silly me didn't think to put that in a branch by itself so I could pull that change around as necessary.  No worries.</p>

<p><em>Light Bulb!</em>  "Ah ha!  I'll just switch into my branch and use <code>git rebase --interactive</code> to rewrite all of those commits and squash them together.  A quick <code>git cherry-pick</code> later and I'll have my Registry object in this new branch on some other functionality I'm working on."</p>

<p>If you've ever used <code>git rebase</code> you can probably see where this is going.  If you haven't, it's probably one of the more dangerous commands&mdash;if not the <em>most</em>&mdash;in Git.  It will literally let you reshape the history of the repository.  Running with scissors is child's play.  No, <code>rebase</code> can really screw you over.  Imagine riding a unicycle while juggling four meat cleavers and you'll have the idea.  Really, and I mean <em>really</em> impressive to watch, but one false move and you're screwed.</p>

<p>So back to my experience.  I proceeded to weed through the 80 or so commits from Monday afternoon and Tuesday morning and pull out everything that didn't relate to the code I wanted.  "Git will just ignore those" I naively thought.  I got it down to the 8 or so commits that had to do with my registry object and its tests and squashed them all into one commit.  I knew I was rewriting the history, but it never occurred to me that I was <em>rewriting</em> history.  I let <code>rebase</code> do its thing, then <code>cherry-pick</code>'d my newly created revision and was off.</p>

<p>Until this afternoon.  Rumor of my changes had made it around the office and someone else wanted to see them.  Since I only track our trunk and not all of our branches and I'm the only there using Git, the easiest solution was to just create a patch to send to him.  Simple enough.  Use <code>git merge --squash</code> and <code>git diff --no-prefix --cached</code> and I'd have a patch he could apply directly to his copy and we're set.</p>

<p>Needless to say, when I started reviewing the patch, I notice there was a lot missing. :-(</p>

<p>Lesson learned.  Don't play with live data when trying new stuff out.  When you miss a bean bag while you're juggling, you don't loose your toe...</p>
