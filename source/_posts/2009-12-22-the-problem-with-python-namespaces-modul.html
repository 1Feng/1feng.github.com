--- 
layout: post
title: The problem with Python namespaces modules (or, Python Namespaces.  There be dragons this way.)
---
<p>Yesterday I <a href="http://twitter.com/tswicegood/status/6897861818">lamented the issues with namespaces</a> in Python. It's not really the namespaces, it's the marketing of namespaces. Newbies to the community (something I still consider myself for most purposes) are drawn to modules thinking that there's a one-to-one relationship between file hierarchy and namespaces. And there is. Well, sort of.</p>

<p>You have to read the entire manual or happen to have someone to point out the difference between namespaces and modules to even realize there is a difference. Under most circumstances, you won't even realize they are different until you start to do something slightly complex. Say, for example, building an application with multiple modules inside a similar namespace, each module in a separate repository and its own history. There needs to be a "there be dragons" warning to let people know.</p>

<p>Those dragons are such: you have two paths inside <code>sys.path</code> that contain similar code. Such as I do with all of the <a href="http://github.com/domain51">Domain51</a> code. Package one has <code>foo</code> as a module while package two contains <code>bar</code>. The assumption would be that Python acts like most other languages and would exhaust it's <code>sys.path</code> trying to find both packages, but that's not the case. It'll get to the first one, then pretend the second doesn't exist.</p>

<p>The fix for this is the explicitness, one of Python's cardinal virtues. You <em>have to declare</em> the namespace in order for it to work. As you don't see this hardly anywhere in Python because Pythonistas feel that namespaces are a bad idea, here's the code you need to include in your __init__.py file to make it declare itself as a namespace:</p>

<pre><code>
import pkg_resources
pkg_resources.declare_namespace(__name__)
</code></pre>

<p></p>

<p>That's it. Now Python becomes smart again, and you can have real namespaces with similar directory structures existing side-by-side. Python is perfectly capable of finding them - now. Which raises an interesting question: why does Python scan the entire sys.path looking for files, building up this list of what declares what namespaces and where only to ignore it later unless they're explicit about it? I haven't dove into the source to be sure, but it seems it would have to scan the <code>__init__.py</code> files in order to know whether there's something there.</p>

<p>But I digress. There's a bigger dragon that's not even hinted at. Python's inability to find modules.</p>

<p>Take, for example, my <a href="http://github.com/tswicegood/python-stupidity">python-stupidity</a> repository on GitHub. Run the <code>test.py</code> file and you can see the error for yourself. There are two <code>barfoo</code> modules within the path, but Python decides to act the villagedolt and stop as soon as it hits the first one that might match. This particular case is caused by <code>foobar</code> trying to import a method from <code>barfoo</code> that doesn't exist in <code>foobar.barfoo</code></p>

<p>This is, in my opinion, a <em>huge</em> issue. Note that <code>foobar.barfoo</code> declared it's namespace. It said loudly, "I am me", and Python ignored that fact in favor of relative includes. Not only that, but it stopped and started pouting as soon as one module that said it was <code>foobar.barfoo</code> couldn't match.</p>

<p>Why not finishing looking through the rest of the <code>sys.path</code>? Why not pay attention to that precious declaration Python wants you to add to explicitly become a namespace?</p>

<p>Like almost all problems with programming languages, however, there is a fix. At first glance, I thought it might be the way PHP handled it - just include a separator at the beginning of the import. That didn't work, but in searching for the solution, I found out that Python supports relative imports through it's support of <a href="http://docs.python.org/tutorial/modules.html#intra-package-references">intra package references</a>. The fix within the <code>foobar</code> module is to do <code>from ..barfoo import base_barfoo</code>, but this only covers you if you're in Python 2.5 or later.</p>

<p>According to my understanding of it, you use it to explicitly say I want a sibling module names X without having to declare the entire namespace or accidentally picking up a module from the global namespace. Fair enough, but my solution to the problem above is to use the relative import to trick Python into thinking it couldn't find a module named the same.</p>

<p>You can <a href="http://github.com/domain51/d51.django.auth/blob/master/d51/django/auth/decorators.py#L3">see the code</a> in the <a href="http://github.com/domain51/d51.django.auth/">d51.django.auth</a> package. I have a <code>d51.django.auth.facebook</code> module which takes precedent over <a href="http://github.com/sciyoshi/pyfacebook/">PyFacebook's</a> <code>facebook</code> module, but only inside the <code>d51.django.auth</code>.</p>

<p>I'm not saying that namespaces are a bad idea in Python or any other language. I'll gladly take namespaces, in <a href="http://php.net/manual/en/language.namespaces.rationale.php">any form I can get them</a> and <a href="http://github.com/tswicegood/argil">use them</a>. They provide a great way to segregate code into small, independent, re-usable packages while continuing to say "I'm from over here." They allow <code>facebook</code> to be used as a module in multiple places without causing an issue, other than the ones listed here.</p>

<p>No, my problem is not with namespaces. My problem is with Python's current method for searching for them; it's lack of exposing namespaces and modules and their differences up front, and it's brain dead way of halting on the first partial hit. I'm amazed that <a href="http://www.python.org/dev/peps/pep-0020/">a language that prides itself on explicitness</a>&mdash;on not doing anything that's not asked for&mdash;decides that it's ok to stop looking for matching code just because it found one thing that doesn't match. It smacks of premature optimization.</p>
