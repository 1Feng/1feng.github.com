
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>1Feng's Blog</title>
	<meta name="author" content="Travis Swicegood">

	
	<meta name="description" content="Introduce 众所周知TCP是可靠的网络传输协议，但是为什么在分布式系统中又认为网络是不可靠的呢？通常有以下两点：
1. 发送方无法确定接收方已经收到请求
2. 发送方无法无法知晓接收方是否处理完请求 可以看出，以上指的都是从应用层的角度观察的结果，而引起以上问题的原因可能有：
- &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom/" rel="alternate" title="1Feng's Blog" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="/javascripts/jquery.min.js"></script>
	
</head>


<body>
	<header id="header" class="inner"><h1><a href="/">1Feng's Blog</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="http://google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:1feng.github.io">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		
		
		<a class="github" href="https://github.com/1feng" title="GitHub">GitHub</a>
		
    
		
		
		
		
		
		<a class="rss" href="/atom/" title="RSS">RSS</a>
		
    
	</div>
	<form class="search" action="http://google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:1feng.github.io">
	</form>
</nav>

</header>
	
		

	
	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/2017/06/06/unreliable-network/">
		
			Unreliable Network</a>
	</h2>
	<div class="entry-content">
		<h1>Introduce</h1>

<blockquote><p>众所周知TCP是可靠的网络传输协议，但是为什么在分布式系统中又认为网络是不可靠的呢？通常有以下两点：
1. 发送方无法确定接收方已经收到请求
2. 发送方无法无法知晓接收方是否处理完请求</p>

<p>可以看出，以上指的都是从应用层的角度观察的结果，而引起以上问题的原因可能有：
- 消息在路由队列中等待转发
- 接收方队列满，发生丢包
- 接收方处理完成，回复的消息在排队或发生丢包
- gc-stop-the-world等</p></blockquote>

<h2>Synchronous network</h2>

<p>像电话网络，有线电视网络等都是所谓synchronous network，他的特点如下：</p>

<ul>
<li><p>一旦连接建立，即享用专线</p></li>
<li><p>专线享有固定的带宽</p></li>
<li><p>路由(routers)没有队列</p></li>
</ul>


<p>以上决定了synchronous network的最大网络延迟是固定有上限的，即可以用timeout来判断消息传输是否存在问题</p>

<h2>Asynchronous network</h2>

<p>既然有synchronous network为什么还要搞以太网这一套呢？原因是为了充分利用带宽，由于互联网上数据传输的大小都不是固定的，使用专线意味着带宽资源的浪费。</p>

<p>因此，Ehernet &amp;&amp; ip 使用了packed-switched协议, 具体如下：</p>

<ol>
<li><p>路由引入队列，最大化线路使用率</p></li>
<li><p>TCP层引入send buffer &amp;&amp; recv buffer来动态的适配数据传输速率(滑动窗口)</p></li>
</ol>


<p>上述的优化本质是在latency和resource utilization之间做trade-off，也因此导致了无上限的延迟时间，即无法选择一个合适的timeoout来进行传输故障检测</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2017-06-06T23:59:00+08:00" pubdate data-updated="true">Jun 6<span>th</span>, 2017</time></div>
	<div class="tags">


	<a class='category' href='/tags/distribute/'>distribute</a>, <a class='category' href='/tags/system/'>system</a>


</div>
	
	<div class="comments"><a href="/2017/06/06/unreliable-network/#duoshuo">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/2017/06/05/timing-and-order/">
		
			Timing and Order</a>
	</h2>
	<div class="entry-content">
		<h1>Introduce</h1>

<blockquote><p>分布式环境面临的两个主要的问题就是网络不可靠和时钟不可靠，这里主要总结时钟问题</p></blockquote>

<h2>Physical Clocks</h2>

<p>我们日常使用的计算机和服务器的物理时钟都是使用的石英(quartz)时钟，这类时钟天生存在误差，虽然铯原子钟的精度更高但是造价昂贵，并不适合商用计算机。</p>

<p>对于商用计算机的时钟误差，通常使用NTP协议来进行时钟同步，然而由于网络的不可靠以及时钟误差NTP同步也会有些问题。</p>

<p>商用计算机利用时英时钟在计算机上实现了两种clock:</p>

<ul>
<li><p>wall clock</p>

<ul>
<li>受NTP同步的影响，时钟会jump forward 或 jump backward来完成时钟同步</li>
<li>如linux上的int gettimeofday(struct timeval <em>tv, struct timezone </em>tz);,返回1970-01-01 00:00:00 +0000 (UTC)至今的秒数和豪秒数</li>
</ul>
</li>
<li><p>monotonic clock</p>

<ul>
<li>不受NTP影响，或者，受NTP同步的影响，时钟只会降低或者升高频率，以尽快完成时钟同步</li>
<li>如linux上的int clock_gettime(clockid_t clk_id, struct timespec *tp),clk_id为CLOCK_MONOTONIC_RAW(本质是jiffies)或者是CLOCK_MONOTONIC；分别对应上述不受NTP影响和受NTP影响两种</li>
</ul>
</li>
</ul>


<p>适用性：</p>

<ul>
<li>wall clock

<ul>
<li>适用于：

<ul>
<li>单机保证时序</li>
</ul>
</li>
<li>不适用：

<ul>
<li>单机计算duration或elapsed time，例如统计timeout，expire</li>
<li>分布式环境下的时序问题</li>
</ul>
</li>
</ul>
</li>
<li>monotonic clock

<ul>
<li>适用于：

<ul>
<li>单机计算duration或elapsed time，例如统计timeout，expire</li>
<li>单机保证时序</li>
</ul>
</li>
<li>不适用：

<ul>
<li>分布式环境下时序问题</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>那么分布式环境下的时序问题如何解决呢?</p>

<ul>
<li>全序(total order)或者高精度的时间点共识(强调某个时间点)：

<ul>
<li>使用原子钟加更严格复杂的时钟同步策略来保证误差</li>
<li>fault-tolent total ordering broadcast</li>
</ul>
</li>
<li>偏序（partial order）：

<ul>
<li>利用因果关系来解决时序问题，即logic clock</li>
</ul>
</li>
</ul>


<h2>Logic Clock</h2>

<p>利用因果关系来实现Logic Clock，见Lamport的<a href="https://github.com/1Feng/learn-distributed-systems/tree/master/theory/timing-and-order/Time-Clocks-and-the-Ordering-of-Events-in-a-Distributed-System">论文</a></p>

<p>利用Logic Clock来保证时序(偏序)，见 <a href="https://github.com/1Feng/learn-distributed-systems/tree/master/theory/timing-and-order/vector-clock">Vector Clock</a></p>

<h2>其他</h2>

<p>一个错误使用wall clock的<a href="http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html">案例</a></p>

<h2>References</h2>

<ol>
<li><a href="http://dataintensive.net/">《Designing Data-Intensive Applications》8.Unreliable Clocks</a></li>
<li><a href="http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html">How to do distributed locking</a></li>
<li><a href="https://github.com/1Feng/learn-distributed-systems/tree/master/theory/timing-and-order/Time-Clocks-and-the-Ordering-of-Events-in-a-Distributed-System">《Time-Clocks-and-the-Ordering-of-Events-in-a-Distributed-System》</a></li>
<li><a href="https://github.com/1Feng/learn-distributed-systems/tree/master/theory/timing-and-order/vector-clock">Vector Clock</a></li>
</ol>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2017-06-05T23:59:00+08:00" pubdate data-updated="true">Jun 5<span>th</span>, 2017</time></div>
	<div class="tags">


	<a class='category' href='/tags/distribute/'>distribute</a>, <a class='category' href='/tags/system/'>system</a>


</div>
	
	<div class="comments"><a href="/2017/06/05/timing-and-order/#duoshuo">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/2017/06/05/vector-clock/">
		
			Vector Clock Summary</a>
	</h2>
	<div class="entry-content">
		<h1>Summary</h1>

<h3>Happend before</h3>

<p>用→来表示<code>hanppend before</code>，对于任意event a, b 有：</p>

<ol>
<li>如果a和b属于同一个process，并且a comes before b, 则 a → b</li>
<li>如果a是某个process发送信息的event，b是另一个process接收该信息的event，那么 a → b</li>
<li>如果 a → b并且 b → c，那么 a → c</li>
</ol>


<p>以上本质是基于一个因果关系(causality)来定义的<code>hanppend before</code></p>

<h1>Summary</h1>

<h3>Why</h3>

<p>Lammport Clock(Logical Clock) 只能通过因果关系推断其Logical Clock的关系，即：</p>

<ul>
<li>如果a → b, 则C(a) &lt; C(b), 反过来并不一定成立（其实就是事后诸葛亮，事件先发生才产生因果关系），同时：

<ul>
<li>同一个process上的两个事件由a → b 得到C(a) &lt; C(b),</li>
<li>但是a,b可能因为和另一个process上的事件c没有因果关系处于并发状态</li>
<li>但是按照Lammport的描述的Logic Clock的实现，C(c)很有可能满足 C(a) &lt; C(c) &lt; C(b)</li>
<li>然而实际情况是c和a,c和b均无因果关系</li>
</ul>
</li>
</ul>


<p>Vector Clock的出现就是为了解决上述问题。</p>

<h3>What</h3>

<p>假设有n个processes，V为n个processes上的事件集合，a,b∈V；</p>

<p>对于vector clock 如果VC(a) &lt; VC(b),仅且仅当：</p>

<ul>
<li>∀i: 0 &lt;= i &lt;= n - 1: VCi(a) &lt;= VCi(b)</li>
<li>∃j: 0 &lt;= j &lt;= n - 1: VCj(a) &lt; VCj(b)</li>
</ul>


<p>通俗的讲就是向量维度匹配并且VC(a)的所有维度都不大于VC(b)并且至少有一个维度小于VC(b),这时候VC(a) &lt; VC(b)</p>

<p>同时：<code>VC(a) &lt; VC(b)   &lt;==&gt; a  → b</code></p>

<h3>How</h3>

<p>processes编号0&#8211;n-1, VC利用数组实现，下标从0到n-1，初始为[0,0,0&#8230;0]</p>

<ol>
<li>对于process i，本地的VC为VCi，对于任意事件发生后 ++VCi[i]</li>
<li>当i向其他process发送数据时，带上本地的VCi</li>
<li>当process j接收到VCi时</li>
<li>++VCj[j]</li>
<li>∀k : 0 &lt;= k &lt;= n - 1:  VCj[k] = max(VCi[k], VCj[k])</li>
</ol>


<h3>Weakness</h3>

<ol>
<li>partial order not total order</li>
<li>无法满足VC(a) &lt; VC(b)时还是无法解决order问题。dynamo论文中的提到的处理方式是将该问题抛给client根据业务处理（PS：dynamo据说已经不用vector clock了）</li>
<li>vector size 随着processes数量线性增长
 - Riak开发者提供了一种<a href="http://basho.com/posts/technical/why-vector-clocks-are-hard/">解决方案</a>,在vector clock中带上各自processes的本地time stamp，当vector size到达指定的阈值后，删除最旧的process在vector clock中的数据；这样造成的问题就是丢失了和最旧的process的因果关系，按照作者的说法，好在这并不会造成数据丢失，just a tradoff！</li>
</ol>


<h3>References</h3>

<ol>
<li><a href="https://en.wikipedia.org/wiki/Vector_clock">Vector Clock In Wikipedia</a></li>
<li><a href="https://www.amazon.com/Distributed-Systems-Algorithmic-Approach-Information/dp/1466552972">《Distributed Systems An Algorithmic Approach Second Edition》 6.3 Vector Clock</a></li>
<li><a href="http://basho.com/posts/technical/why-vector-clocks-are-hard/">Why Vector Clocks Are Hard</a></li>
</ol>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2017-06-05T00:59:00+08:00" pubdate data-updated="true">Jun 5<span>th</span>, 2017</time></div>
	<div class="tags">


	<a class='category' href='/tags/distribute/'>distribute</a>, <a class='category' href='/tags/system/'>system</a>


</div>
	
	<div class="comments"><a href="/2017/06/05/vector-clock/#duoshuo">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/2017/06/03/Time-Clocks-and-the-Ordering-of-Events-in-a-Distributed-System/">
		
			《Time, Clocks, and the Ordering of Events in a Distributed System》summary</a>
	</h2>
	<div class="entry-content">
		<h1>Summary</h1>

<h3>Happend before</h3>

<p>用→来表示<code>hanppend before</code>，对于任意event a, b 有：</p>

<ol>
<li>如果a和b属于同一个process，并且a comes before b, 则 a → b</li>
<li>如果a是某个process发送信息的event，b是另一个process接收该信息的event，那么 a → b</li>
<li>如果 a → b并且 b → c，那么 a → c</li>
</ol>


<p>以上本质是基于一个因果关系(causality)来定义的<code>hanppend before</code></p>

<p><code>concurrence</code>意味着a → b不成立并且b→a也不成立，即a,b之间缺少因果关系</p>

<p>b →  c 并且 a  →  c, 但是a,b并不能推导出因果关系，因此<code>happend before</code>是partial order.
同时由于a → a不成立，所以<code>happend before</code>是反自反(irreflexive)的partial order</p>

<h3>logical clocks</h3>

<p>定义Ci(b)为event b在process i 上发生时的clock。</p>

<p>对于任意的events a,b：</p>

<blockquote><p>如果a → b,则C(a)&lt; C(b)</p></blockquote>

<p>显而易见：</p>

<ol>
<li>如果a,b同属于process Pi, 并且 a comes before b, 则C(a) &lt; C(b)</li>
<li>如果a是Pi上发送信息的event，b是Pj上接收该信息的event，那么Ci(a) &lt; Cj(b)</li>
</ol>


<p>具体实现：</p>

<ol>
<li>对于任意Pi在两个successive event之间会增加Ci, Ci += 1</li>
<li>以下</li>
<li>a. 如果a是Pi上发送信息的event，信息m包含一个时间戳Tm = Ci(a)</li>
<li>b. 当Pj收到信息m，设置Cj = max(Cj, Tm) + 1</li>
</ol>


<p>Logical Clock 的缺点：a, b可能同时发生，C(a) &lt; C(b)并不能推断出a → b</p>

<h3>total ordering</h3>

<blockquote><p>In mathematics, a linear order, total order, simple order, or (non-strict) ordering is a binary relation on some set X, which is antisymmetric, transitive, and total. A set paired with a total order is called a totally ordered set, a linearly ordered set, a simply ordered set, or a chain. &#8212;- from wikipedia</p></blockquote>

<p>定义关系=>如下：</p>

<blockquote><p>如果a属于Pi，b属于Pj，a => b当且仅当要么Ci(a) &lt; Ci(b)要么Ci(a) = Ci(b) 并且Pi &lt; Pj</p></blockquote>

<p>Pi &lt; Pj可以是process name 字典序或者数字标示的顺序。</p>

<p>total ordering强调对于任意两个元素都有可比性</p>

<p>paper中举例使用no-fault-tolent total ordering解决分布式情况下mutual exclusion的问题</p>

<p>值得特别强调的一点，这里的total ordering和<code>hanppend before</code>没有关系，但是total ordering的意义在于可以用在例如mutual exclusion场景，用顺序来保证fairness（一般的mutual exclusion的关系是FIFO来保证fairness的）</p>

<h3>Anomalous Behavior</h3>

<p>例如：</p>

<ol>
<li>event a : P 发送消息到R</li>
<li>event b :  P发送消息到Q，Q将消息转发给R</li>
</ol>


<p>对于P而言 a→b,但是由于网络延迟R就不一定这么认为了。</p>

<p>解决方法有两种：</p>

<ol>
<li>发送的消息中带上logical clock</li>
<li>利用Physical Clock</li>
</ol>


<h3>Physical Clocks</h3>

<p>大概介绍了什么样（主要指同步）的physical clock可以用来解决上述的问题。</p>

<h3>References</h3>

<ol>
<li><a href="https://en.wikipedia.org/wiki/Lamport_timestamps">wikipedia</a></li>
<li><a href="https://www.amazon.com/Distributed-Systems-Algorithmic-Approach-Information/dp/1466552972">《Distributed Systems An Algorithmic Approach Second Edition》 6.2 Logical Clock</a></li>
<li><a href="https://www.amazon.com/Distributed-Systems-Algorithmic-Approach-Information/dp/1466552972">《Distributed Systems An Algorithmic Approach Second Edition》 7.2 Solutions On Message-Passing Systems</a></li>
</ol>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2017-06-03T23:59:00+08:00" pubdate data-updated="true">Jun 3<span>rd</span>, 2017</time></div>
	<div class="tags">


	<a class='category' href='/tags/distribute/'>distribute</a>, <a class='category' href='/tags/system/'>system</a>


</div>
	
	<div class="comments"><a href="/2017/06/03/Time-Clocks-and-the-Ordering-of-Events-in-a-Distributed-System/#duoshuo">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/2016/09/10/leveldb-read/">
		
			Leveldb源码笔记之读操作</a>
	</h2>
	<div class="entry-content">
		<h3>key逻辑分类</h3>

<p>根据我们之前文章的描述，leveldb的数据存储可能存在在内存的memtable中，或者磁盘的sstalbe中，但是key的实际存储格式会略微有差异，代码里按照存储的位置，划分为以下几种类型：</p>

<blockquote><p><strong>memtable</strong>: 逻辑上称为memtable_key</p>

<p><strong>sstalbe</strong>: 逻辑上称为internal_key</p>

<p><strong>key</strong>: 用户提供的key，我们称之为user_key</p></blockquote>

<p>当用户去查询某个key时，leveldb会先利用key构建起Lookupkey类</p>

<p>Lookupkey类内部的完整数据即memtable_key，可以方便的利用成员函数截取memtable_key,internal_key,user_key以方便去memtalble和sstable中查询</p>

<p>事实上LookupKey是由 key， sequence number组成的，如之前文章提到:</p>

<ul>
<li>如果普通Get()操作，sequence number 为 last sequence number</li>
<li>如果是使用的snapshot, sequence number 为 snapshot sequence number</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// dbformat.h</span>
</span><span class='line'><span class="c1">// lookup key format:</span>
</span><span class='line'><span class="c1">// start_       kstart_                                         end_</span>
</span><span class='line'><span class="c1">//   |             |                                             |</span>
</span><span class='line'><span class="c1">//   |             |&lt;--user_key--&gt;|                              |</span>
</span><span class='line'><span class="c1">//   |             |&lt;---------------internal_key----------------&gt;|</span>
</span><span class='line'><span class="c1">//   |&lt;---------------------memtable_key------------------------&gt;|</span>
</span><span class='line'><span class="c1">//   -------------------------------------------------------------</span>
</span><span class='line'><span class="c1">//   |  1--5 byte  | klenght byte |           8 byte             |</span>
</span><span class='line'><span class="c1">//   -------------------------------------------------------------</span>
</span><span class='line'><span class="c1">//   | klenght + 8 |   raw key    | pack(sequence number, type)) |</span>
</span><span class='line'><span class="c1">//   -------------------------------------------------------------</span>
</span><span class='line'><span class="c1">// A helper class useful for DBImpl::Get()</span>
</span><span class='line'><span class="k">class</span> <span class="nc">LookupKey</span> <span class="p">{</span>
</span><span class='line'> <span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="c1">// Initialize *this for looking up user_key at a snapshot with</span>
</span><span class='line'>  <span class="c1">// the specified sequence number.</span>
</span><span class='line'>  <span class="n">LookupKey</span><span class="p">(</span><span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">user_key</span><span class="p">,</span> <span class="n">SequenceNumber</span> <span class="n">sequence</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="o">~</span><span class="n">LookupKey</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Return a key suitable for lookup in a MemTable.</span>
</span><span class='line'>  <span class="n">Slice</span> <span class="n">memtable_key</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Slice</span><span class="p">(</span><span class="n">start_</span><span class="p">,</span> <span class="n">end_</span> <span class="o">-</span> <span class="n">start_</span><span class="p">);</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Return an internal key (suitable for passing to an internal iterator)</span>
</span><span class='line'>  <span class="n">Slice</span> <span class="n">internal_key</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Slice</span><span class="p">(</span><span class="n">kstart_</span><span class="p">,</span> <span class="n">end_</span> <span class="o">-</span> <span class="n">kstart_</span><span class="p">);</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Return the user key</span>
</span><span class='line'>  <span class="n">Slice</span> <span class="n">user_key</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Slice</span><span class="p">(</span><span class="n">kstart_</span><span class="p">,</span> <span class="n">end_</span> <span class="o">-</span> <span class="n">kstart_</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'> <span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">start_</span><span class="p">;</span>
</span><span class='line'>  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">kstart_</span><span class="p">;</span>
</span><span class='line'>  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">end_</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">char</span> <span class="n">space_</span><span class="p">[</span><span class="mi">200</span><span class="p">];</span>      <span class="c1">// Avoid allocation for short keys</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// No copying allowed</span>
</span><span class='line'>  <span class="n">LookupKey</span><span class="p">(</span><span class="k">const</span> <span class="n">LookupKey</span><span class="o">&amp;</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">LookupKey</span><span class="o">&amp;</span><span class="p">);</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>如图:
<img src="/images/blog_images/leveldb/leveldb-keys.png" alt="" /></p>

<h3>读操作</h3>

<p>图示Get()操作的基本逻辑如下：
<img src="/images/blog_images/leveldb/leveldb-read.png" alt="" />
以上我们是假设sstable没有filter的情况下的操作逻辑</p>

<h3>cache</h3>

<p>无论是table cache，还是block cache，都是使用了相同的数据结构LRUCache来实现的，区别只在于内部存储的数据不同。</p>

<p>LRUCache是通过k/v方式存储的，对于：</p>

<p><strong>TableCache</strong>:</p>

<ul>
<li>key: 其实就是file number</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// table_cache.cc</span>
</span><span class='line'><span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">file_number</span><span class="p">)];</span>
</span><span class='line'><span class="n">EncodeFixed64</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">file_number</span><span class="p">);</span>
</span><span class='line'><span class="n">Slice</span> <span class="n">key</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>value: TableAndFile， 其实主要是sstable index block里的数据</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// table_cache.cc</span>
</span><span class='line'><span class="k">struct</span> <span class="n">TableAndFile</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">RandomAccessFile</span><span class="o">*</span> <span class="n">file</span><span class="p">;</span>
</span><span class='line'>  <span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// table.cc</span>
</span><span class='line'><span class="c1">// Table里的主要数据即下述</span>
</span><span class='line'><span class="k">struct</span> <span class="n">Table</span><span class="o">::</span><span class="n">Rep</span> <span class="p">{</span>
</span><span class='line'>    <span class="o">~</span><span class="n">Rep</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">delete</span> <span class="n">filter</span><span class="p">;</span>
</span><span class='line'>      <span class="k">delete</span> <span class="p">[]</span> <span class="n">filter_data</span><span class="p">;</span>
</span><span class='line'>      <span class="k">delete</span> <span class="n">index_block</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Options</span> <span class="n">options</span><span class="p">;</span>
</span><span class='line'>    <span class="n">Status</span> <span class="n">status</span><span class="p">;</span>
</span><span class='line'>    <span class="n">RandomAccessFile</span><span class="o">*</span> <span class="n">file</span><span class="p">;</span>
</span><span class='line'>    <span class="n">uint64_t</span> <span class="n">cache_id</span><span class="p">;</span>
</span><span class='line'>    <span class="n">FilterBlockReader</span><span class="o">*</span> <span class="n">filter</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filter_data</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">BlockHandle</span> <span class="n">metaindex_handle</span><span class="p">;</span>  <span class="c1">// Handle to metaindex_block: saved from footer</span>
</span><span class='line'>    <span class="n">Block</span><span class="o">*</span> <span class="n">index_block</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>BlockCache</strong>:</p>

<ul>
<li>key: 其实是 cache_id 和 block 在sstable中的offset的组合</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// table.cc</span>
</span><span class='line'><span class="kt">char</span> <span class="n">cache_key_buffer</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
</span><span class='line'><span class="c1">// 构造block_cache 的key</span>
</span><span class='line'><span class="n">EncodeFixed64</span><span class="p">(</span><span class="n">cache_key_buffer</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">rep_</span><span class="o">-&gt;</span><span class="n">cache_id</span><span class="p">);</span>
</span><span class='line'><span class="n">EncodeFixed64</span><span class="p">(</span><span class="n">cache_key_buffer</span><span class="o">+</span><span class="mi">8</span><span class="p">,</span> <span class="n">handle</span><span class="p">.</span><span class="n">offset</span><span class="p">());</span>
</span><span class='line'><span class="n">Slice</span> <span class="n">key</span><span class="p">(</span><span class="n">cache_key_buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cache_key_buffer</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>value: data block 内容</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// block.h</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Block</span> <span class="p">{</span>
</span><span class='line'> <span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="c1">// Initialize the block with the specified contents.</span>
</span><span class='line'>  <span class="k">explicit</span> <span class="n">Block</span><span class="p">(</span><span class="k">const</span> <span class="n">BlockContents</span><span class="o">&amp;</span> <span class="n">contents</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="o">~</span><span class="n">Block</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">size_t</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">size_</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>  <span class="n">Iterator</span><span class="o">*</span> <span class="n">NewIterator</span><span class="p">(</span><span class="k">const</span> <span class="n">Comparator</span><span class="o">*</span> <span class="n">comparator</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'> <span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="n">uint32_t</span> <span class="n">NumRestarts</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">data_</span><span class="p">;</span>
</span><span class='line'>  <span class="n">size_t</span> <span class="n">size_</span><span class="p">;</span>
</span><span class='line'>  <span class="n">uint32_t</span> <span class="n">restart_offset_</span><span class="p">;</span>     <span class="c1">// Offset in data_ of restart array</span>
</span><span class='line'>  <span class="kt">bool</span> <span class="n">owned_</span><span class="p">;</span>                  <span class="c1">// Block owns data_[]</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// No copying allowed</span>
</span><span class='line'>  <span class="n">Block</span><span class="p">(</span><span class="k">const</span> <span class="n">Block</span><span class="o">&amp;</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Block</span><span class="o">&amp;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">class</span> <span class="nc">Iter</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<h4>cache 逻辑结构图示</h4>

<p><img src="/images/blog_images/leveldb/leveldb-cache.png" alt="" /></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2016-09-10T22:07:00+08:00" pubdate data-updated="true">Sep 10<span>th</span>, 2016</time></div>
	<div class="tags">


	<a class='category' href='/tags/distribute/'>distribute</a>, <a class='category' href='/tags/leveldb/'>leveldb</a>, <a class='category' href='/tags/system/'>system</a>


</div>
	
	<div class="comments"><a href="/2016/09/10/leveldb-read/#duoshuo">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/2016/09/06/leveldb-compact/">
		
			leveldb源码笔记之Compact</a>
	</h2>
	<div class="entry-content">
		<h3>简介</h3>

<p>leveldb中只有minor compaction 和 major compaction两种</p>

<ul>
<li>代码中通过调用<code>DBImpl::MaybeScheduleCompaction()</code>来触发两种compaction</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// db_impl.cc</span>
</span><span class='line'><span class="kt">void</span> <span class="n">DBImpl</span><span class="o">::</span><span class="n">MaybeScheduleCompaction</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">mutex_</span><span class="p">.</span><span class="n">AssertHeld</span><span class="p">();</span>
</span><span class='line'>  <span class="c1">// 确保只有一个后台线程在做compact</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">bg_compaction_scheduled_</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// Already scheduled</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">shutting_down_</span><span class="p">.</span><span class="n">Acquire_Load</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// DB is being deleted; no more background compactions</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bg_error_</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// Already got an error; no more changes</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">imm_</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
</span><span class='line'>             <span class="n">manual_compaction_</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
</span><span class='line'>             <span class="o">!</span><span class="n">versions_</span><span class="o">-&gt;</span><span class="n">NeedsCompaction</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// No work to be done</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">bg_compaction_scheduled_</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">// 启动compact线程,主要逻辑是通过DBImpl::BackgroundCompaction()实现</span>
</span><span class='line'>    <span class="n">env_</span><span class="o">-&gt;</span><span class="n">Schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">DBImpl</span><span class="o">::</span><span class="n">BGWork</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>调用时机:</p>

<ul>
<li>1.每次写入前，需要确保空间充足，如果空间不足，尝试将memtable转换为immutable-memtable，之后调用<code>DBImpl::MaybeScheduleCompaction()</code></li>
<li>2.每次重启db，binlog recover结束后，会触发调用<code>DBImpl::MaybeScheduleCompaction()</code></li>
<li>3.每次读取一条记录结束时会触发调用<code>DBImpl::MaybeScheduleCompaction()</code></li>
</ul>


<h3>minor compaction:</h3>

<h4>方式：</h4>

<ul>
<li>将immutalbe-memtable dump到磁盘，形成sstable</li>
<li>sstable一般位于level-0,如果sstable的key范围和当前level没有重叠会尝试下移，最多不会超过<code>config::kMaxMemCompactLevel(默认为2)</code></li>
</ul>


<h4>触发时机:</h4>

<ul>
<li>每次调用BackGroudCompaction如果存在immutalbe-memtable都会触发将其dump到磁盘</li>
</ul>


<h3>major compaction</h3>

<h4>方式：</h4>

<ul>
<li>将level-n的sstable 与 level-(n+1)中与之存在key范围重叠的sstable多路归并，生成level-(n+1)的sstable</li>
<li>如果是level-0,则由于level-0中sstable之间key有重叠，所以level-0参与compact的sstable可能不止一个</li>
</ul>


<h4>触发时机:</h4>

<p>第一种是size触发类型(优先)：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// version_set.cc</span>
</span><span class='line'><span class="kt">void</span> <span class="n">VersionSet</span><span class="o">::</span><span class="n">Finalize</span><span class="p">(</span><span class="n">Version</span><span class="o">*</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// Precomputed best level for next compaction</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">best_level</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">double</span> <span class="n">best_score</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">level</span> <span class="o">&lt;</span> <span class="n">config</span><span class="o">::</span><span class="n">kNumLevels</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">level</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">double</span> <span class="n">score</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">// We treat level-0 specially by bounding the number of files</span>
</span><span class='line'>      <span class="c1">// instead of number of bytes for two reasons:</span>
</span><span class='line'>      <span class="c1">//</span>
</span><span class='line'>      <span class="c1">// 对于较大的write buffer, 不过多的进行levle-0的compactions是好的</span>
</span><span class='line'>      <span class="c1">// (1) With larger write-buffer sizes, it is nice not to do too</span>
</span><span class='line'>      <span class="c1">// many level-0 compactions.</span>
</span><span class='line'>      <span class="c1">//</span>
</span><span class='line'>      <span class="c1">// 因为每次读操作都会触发level-0的归并，因此当个别的文件size很小的时候</span>
</span><span class='line'>      <span class="c1">// 我们期望避免level-0有太多文件存在</span>
</span><span class='line'>      <span class="c1">// (2) The files in level-0 are merged on every read and</span>
</span><span class='line'>      <span class="c1">// therefore we wish to avoid too many files when the individual</span>
</span><span class='line'>      <span class="c1">// file size is small (perhaps because of a small write-buffer</span>
</span><span class='line'>      <span class="c1">// setting, or very high compression ratios, or lots of</span>
</span><span class='line'>      <span class="c1">// overwrites/deletions).</span>
</span><span class='line'>      <span class="n">score</span> <span class="o">=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">files_</span><span class="p">[</span><span class="n">level</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span>
</span><span class='line'>          <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">config</span><span class="o">::</span><span class="n">kL0_CompactionTrigger</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">// Compute the ratio of current size to size limit.</span>
</span><span class='line'>      <span class="k">const</span> <span class="n">uint64_t</span> <span class="n">level_bytes</span> <span class="o">=</span> <span class="n">TotalFileSize</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">files_</span><span class="p">[</span><span class="n">level</span><span class="p">]);</span>
</span><span class='line'>      <span class="n">score</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">level_bytes</span><span class="p">)</span> <span class="o">/</span> <span class="n">MaxBytesForLevel</span><span class="p">(</span><span class="n">level</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">score</span> <span class="o">&gt;</span> <span class="n">best_score</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">best_level</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span>
</span><span class='line'>      <span class="n">best_score</span> <span class="o">=</span> <span class="n">score</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">v</span><span class="o">-&gt;</span><span class="n">compaction_level_</span> <span class="o">=</span> <span class="n">best_level</span><span class="p">;</span>
</span><span class='line'>  <span class="n">v</span><span class="o">-&gt;</span><span class="n">compaction_score_</span> <span class="o">=</span> <span class="n">best_score</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>对于level-0:</p>

<ul>
<li>score = level-0文件数/config::kL0_CompactionTrigger(默认为4)</li>
</ul>
</li>
<li><p>对于level-n(n>0)：</p>

<ul>
<li>score = 当前level的字节数 / (10<sup>n</sup> * 2<sup>20)</sup>  2<sup>20</sup> 即1MB</li>
</ul>
</li>
<li><p>score >= 1,当前level就会被标识起来，等待触发 compaction</p></li>
</ul>


<p>第二种是seek触发:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// version_edit.h</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 记录了文件编号， 文件大小，最小key，最大key</span>
</span><span class='line'><span class="c1">// sstable文件的命名就是按照file number + 特定后缀完成的</span>
</span><span class='line'><span class="k">struct</span> <span class="n">FileMetaData</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">refs</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">allowed_seeks</span><span class="p">;</span>          <span class="c1">// Seeks allowed until compaction</span>
</span><span class='line'>  <span class="n">uint64_t</span> <span class="n">number</span><span class="p">;</span>
</span><span class='line'>  <span class="n">uint64_t</span> <span class="n">file_size</span><span class="p">;</span>         <span class="c1">// File size in bytes</span>
</span><span class='line'>  <span class="n">InternalKey</span> <span class="n">smallest</span><span class="p">;</span>       <span class="c1">// Smallest internal key served by table</span>
</span><span class='line'>  <span class="n">InternalKey</span> <span class="n">largest</span><span class="p">;</span>        <span class="c1">// Largest internal key served by table</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">FileMetaData</span><span class="p">()</span> <span class="o">:</span> <span class="n">refs</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">allowed_seeks</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">),</span> <span class="n">file_size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// version_set.cc</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Apply all of the edits in *edit to the current state.</span>
</span><span class='line'><span class="kt">void</span> <span class="n">Apply</span><span class="p">(</span><span class="n">VersionEdit</span><span class="o">*</span> <span class="n">edit</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">edit</span><span class="o">-&gt;</span><span class="n">new_files_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">const</span> <span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="n">edit</span><span class="o">-&gt;</span><span class="n">new_files_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">;</span>
</span><span class='line'>    <span class="n">FileMetaData</span><span class="o">*</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileMetaData</span><span class="p">(</span><span class="n">edit</span><span class="o">-&gt;</span><span class="n">new_files_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="p">);</span>
</span><span class='line'>    <span class="n">f</span><span class="o">-&gt;</span><span class="n">refs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">// We arrange to automatically compact this file after</span>
</span><span class='line'>    <span class="c1">// a certain number of seeks.  Let&#39;s assume:</span>
</span><span class='line'>    <span class="c1">//   (1) One seek costs 10ms</span>
</span><span class='line'>    <span class="c1">//   (2) Writing or reading 1MB costs 10ms (100MB/s)</span>
</span><span class='line'>    <span class="c1">//   (3) A compaction of 1MB does 25MB of IO:</span>
</span><span class='line'>    <span class="c1">//        1MB read from this level</span>
</span><span class='line'>    <span class="c1">//        10-12MB read from next level(boundaries may be misaligned)</span>
</span><span class='line'>    <span class="c1">//        10-12MB written to next level</span>
</span><span class='line'>    <span class="c1">// This implies that 25 seeks cost the same as the compaction</span>
</span><span class='line'>    <span class="c1">// of 1MB of data.  I.e., one seek costs approximately the</span>
</span><span class='line'>    <span class="c1">// same as the compaction of 40KB of data.  We are a little</span>
</span><span class='line'>    <span class="c1">// conservative and allow approximately one seek for every 16KB</span>
</span><span class='line'>    <span class="c1">// of data before triggering a compaction.</span>
</span><span class='line'>    <span class="c1">// 1次seek相当与compact 40kb的data,</span>
</span><span class='line'>    <span class="c1">// 那么n次seek大概和compact一个sstable相当(n = sstable_size / 40kb)</span>
</span><span class='line'>    <span class="c1">// 保守点，这里搞了个16kb</span>
</span><span class='line'>    <span class="n">f</span><span class="o">-&gt;</span><span class="n">allowed_seeks</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">file_size</span> <span class="o">/</span> <span class="mi">16384</span><span class="p">);</span>  <span class="c1">// 2^14 == 16384 == 16kb</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">allowed_seeks</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">)</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">allowed_seeks</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>当一个新的sstable建立时，会有一个allowed_seeks的初值：

<ul>
<li>作者认为1次sstable的seek（<code>此处的seek就是指去sstable里查找指定key</code>），相当于compact 40kb的数据，那么 sstable size / 40kb  次的seek操作，大概和compact 一个 sstable相当</li>
<li>保守的做法，allowed_seeks的初值为file_size/16kb</li>
<li>如果allowed_seeks小于100，令其为100</li>
</ul>
</li>
<li>每当Get操作触发磁盘读，即sstable被读取，该数值就会减一；如果有多个sstable被读取，则仅首个被读取的sstable的sllowed_seeks减一</li>
<li>allowed_seeks == 0 时，该sstable以及其所处level会被标识起来，等待触发 compaction</li>
</ul>


<h4>sstable选择：</h4>

<ul>
<li><p>针对size触发类型，默认从当前level的首个sstable开始执行</p></li>
<li><p>seek触发相对简单，sstable已经选择好了</p></li>
<li><p>对于level-0,需要将与选中的sstable存在key重叠的sstable也包含进此次compact</p></li>
<li><p>对于level-(n+1)，需要将与level-n中选中的sstable存在key重叠的sstable包含进此次compact</p>

<blockquote><p>由于level-(n+1)多个sstable的参与扩展了整个compact的key的范围, 我们可以使用该key范围将level-n中更多的sstable包含进此次compact
前提是保证level-n更多sstable的参与不会导致level-(n+1)的sstable数量再次增长.
同时，参与整个compaction的字节数不超过kExpandedCompactionByteSizeLimit = 25 * kTargetFileSize = 25 * 2MB;</p></blockquote></li>
<li><p>为了保持公平，保证某个level中每个sstable都有机会参与compact:</p>

<ul>
<li>存储当前level首次compact的sstable(s)的largest key，存入compact_point_[level]</li>
<li>当前level如果再次被size触发进行compact时，选择首个largest key大于compact_point_[level] sstable进行compact</li>
</ul>
</li>
</ul>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2016-09-06T14:55:00+08:00" pubdate data-updated="true">Sep 6<span>th</span>, 2016</time></div>
	<div class="tags">


	<a class='category' href='/tags/distribute/'>distribute</a>, <a class='category' href='/tags/leveldb/'>leveldb</a>


</div>
	
	<div class="comments"><a href="/2016/09/06/leveldb-compact/#duoshuo">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/2016/08/24/mvcc-and-manifest/">
		
			leveldb源码笔记之MVCC && Manifest</a>
	</h2>
	<div class="entry-content">
		<h3>MVCC</h3>

<p><strong>问题</strong>:
针对同一条记录，如果读和写在同一时间发生时，reader可能会读取到不一致或者写了一半的数据</p>

<p><strong>常见解决方案</strong></p>

<blockquote><p>悲观锁：</p>

<blockquote><p>最简单的方式,即通过锁来控制并发，但是效率非常的低,增加的产生死锁的机会</p></blockquote>

<p>乐观锁：</p>

<blockquote><p>它假设多用户并发的事物在处理时不会彼此互相影响，各食物能够在不产生锁的的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚;这样做不会有锁竞争更不会产生思索，但如果数据竞争的概率较高，效率也会受影响</p></blockquote>

<p>MVCC &#8211; Multiversion concurrency control:</p>

<blockquote><p>每一个执行操作的用户，看到的都是数据库特定时刻的的快照(snapshot), writer的任何未完成的修改都不会被其他的用户所看到;当对数据进行更新的时候并是不直接覆盖，而是先进行标记, 然后在其他地方添加新的数据，从而形成一个新版本, 此时再来读取的reader看到的就是最新的版本了。所以这种处理策略是维护了多个版本的数据的,但只有一个是最新的。</p></blockquote></blockquote>

<h3>Key/Value</h3>

<p>如<a href="http://1feng.github.io/2016/08/18/leveldb-write/">前文</a>所述，leveldb中写入一条记录，仅仅是先写入binlog，然后写入memtable</p>

<ul>
<li><p><strong>binlog</strong>: binlog的写入只需要append，无需并发控制</p></li>
<li><p><strong>memtable</strong>: memtable是使用Memory Barriers技术实现的无锁的skiplist</p></li>
<li><p><strong>更新</strong>: 真正写入memtable中参与skiplist排序的key其实是包含sequence number的，所以更新操作其实只是写入了一条新的k/v记录, 真正的更新由compact完成</p></li>
<li><p><strong>删除</strong>: 如<a href="http://1feng.github.io/2016/08/18/leveldb-write/">前文</a>提到，删除一条Key时，仅仅是将type标记为kTypeDeletion，写入(同上述写入逻辑)了一条新的记录，并没有真正删除,真正的删除也是由compact完成的</p></li>
</ul>


<h4>Sequence Number</h4>

<ul>
<li><p>sequence number 是一个由VersionSet直接持有的全局的编号，每次写入（<code>注意批量写入时sequence number是相同的</code>），就会递增</p></li>
<li><p>根据我们之前对写入操作的分析，我们可以看到，当插入一条key的时候，实际参与排序，存储的是key和sequence number以及type组成的
InternalKey</p></li>
<li><p>当我们进行Get操作时，我们只需要找到目标key，同时其sequence number &lt;= specific sequence number</p>

<ul>
<li>普通的读取，sepcific sequence number == last sequence number</li>
<li>snapshot读取，sepcific sequenc number == snapshot sequence number</li>
</ul>
</li>
</ul>


<h4>Snapshot</h4>

<p>snapshot 其实就是一个sequence number，获取snapshot，即获取当前的last sequence number</p>

<p>例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'>  <span class="n">string</span> <span class="n">key</span> <span class="o">=</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
</span><span class='line'>  <span class="n">string</span> <span class="n">value</span> <span class="o">=</span> <span class="sc">&#39;b&#39;</span><span class="p">;</span>
</span><span class='line'>  <span class="n">leveldb</span><span class="o">::</span><span class="n">Status</span> <span class="n">s</span> <span class="o">=</span> <span class="n">db</span><span class="o">-&gt;</span><span class="n">Put</span><span class="p">(</span><span class="n">leveldb</span><span class="o">::</span><span class="n">WriteOptions</span><span class="p">(),</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
</span><span class='line'>  <span class="n">assert</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span>
</span><span class='line'>  <span class="n">leveldb</span><span class="o">::</span><span class="n">ReadOptions</span> <span class="n">options</span><span class="p">;</span>
</span><span class='line'>  <span class="n">options</span><span class="p">.</span><span class="n">snapshot</span> <span class="o">=</span> <span class="n">db</span><span class="o">-&gt;</span><span class="n">GetSnapshot</span><span class="p">();</span>
</span><span class='line'>  <span class="n">string</span> <span class="n">value</span> <span class="o">=</span> <span class="sc">&#39;c&#39;</span><span class="p">;</span>
</span><span class='line'>  <span class="n">leveldb</span><span class="o">::</span><span class="n">Status</span> <span class="n">s</span> <span class="o">=</span> <span class="n">db</span><span class="o">-&gt;</span><span class="n">Put</span><span class="p">(</span><span class="n">leveldb</span><span class="o">::</span><span class="n">WriteOptions</span><span class="p">(),</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
</span><span class='line'>  <span class="n">assert</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span>
</span><span class='line'>  <span class="c1">// ...</span>
</span><span class='line'>  <span class="c1">// ...</span>
</span><span class='line'>  <span class="n">value</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span><span class='line'>  <span class="n">s</span> <span class="o">=</span> <span class="n">db</span><span class="o">-&gt;</span><span class="n">Get</span><span class="p">(</span><span class="n">leveldb</span><span class="o">::</span><span class="n">ReadOptions</span><span class="p">(),</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>   <span class="c1">// value == &#39;c&#39;</span>
</span><span class='line'>  <span class="n">assert</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span>
</span><span class='line'>  <span class="n">s</span> <span class="o">=</span> <span class="n">db</span><span class="o">-&gt;</span><span class="n">Get</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>   <span class="c1">// value == &#39;b&#39;</span>
</span><span class='line'>  <span class="n">assert</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>我们知道在sstable compact的时候，才会执行真正的删除或覆盖，而覆盖则是如果发现两条相同的记录
会丢弃旧的(sequence number较小)一条，但是这同时会破坏掉snapshot</li>
<li>那么 key = &#8216;a&#8217;, value = &#8216;b&#8217;是如何避免compact时被丢弃掉的呢？

<ul>
<li>db在内存中记录了当前用户持有的所有snapshot</li>
<li>smallest snapshot = has snapshot ? oldest snapshot : last sequence number</li>
<li>当进行compact时，如果发现两条相同的记录，只有当两条记录的sequence number都小于 smallest snapshot 时才丢弃掉其中sequence number较小的一条</li>
</ul>
</li>
</ul>


<h3>Sstable</h3>

<p>sstable级别的MVCC是利用Version和VersionEdit实现的：</p>

<ul>
<li>只有一个current version，持有了最新的sstable集合</li>
<li>VersionEdit代表了一次current version的更新, 新增了那些sstable，哪些sstable已经没用了等</li>
</ul>


<p><img src="/images/blog_images/leveldb/mvcc.png" alt="" /></p>

<h3>Mainifest</h3>

<p>每次current version 更新的数据(即新产生的VersionEdit)都写入mainifest文件，以便重启时recover</p>

<p><img src="/images/blog_images/leveldb/write_a_manifest.png" alt="" /></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2016-08-24T15:51:00+08:00" pubdate data-updated="true">Aug 24<span>th</span>, 2016</time></div>
	<div class="tags">


	<a class='category' href='/tags/distribute/'>distribute</a>, <a class='category' href='/tags/leveldb/'>leveldb</a>, <a class='category' href='/tags/system/'>system</a>


</div>
	
	<div class="comments"><a href="/2016/08/24/mvcc-and-manifest/#duoshuo">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/2016/08/22/sstable-summary/">
		
			Leveldb源码笔记之sstable</a>
	</h2>
	<div class="entry-content">
		<h3>整体看下sstable的组要组成，如下：</h3>

<p><img src="/images/blog_images/leveldb/sstable.png" alt="" /></p>

<h3>sstalbe 生成细节</h3>

<blockquote><p>sstable 生成时机:</p>

<p>minor compaction</p>

<blockquote><p>immutable-memtable 中的key/value dump到磁盘，生成sstable</p></blockquote>

<p>major compaction</p>

<blockquote><p>sstable compact（level-n sstable(s)与level-n+1 sstables多路归并）生成level-n+1的sstable</p></blockquote></blockquote>

<h4>首先是写入data block:</h4>

<p><img src="/images/blog_images/leveldb/write_a_data_block.png" alt="" /></p>

<h4>data block都写入完成后，接下来是meta block:</h4>

<p><img src="/images/blog_images/leveldb/write_a_meta_block.png" alt="" /></p>

<h4>然后是data/meta block索引信息data/meta index block写入:</h4>

<p><img src="/images/blog_images/leveldb/write_a_index_block.png" alt="" /></p>

<h4>最后将index block的索引信息写入Footer</h4>

<p><img src="/images/blog_images/leveldb/write_a_footer.png" alt="" /></p>

<h4>一个完整的sstable形成!</h4>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2016-08-22T11:19:00+08:00" pubdate data-updated="true">Aug 22<span>nd</span>, 2016</time></div>
	<div class="tags">


	<a class='category' href='/tags/distribute/'>distribute</a>, <a class='category' href='/tags/leveldb/'>leveldb</a>, <a class='category' href='/tags/system/'>system</a>


</div>
	
	<div class="comments"><a href="/2016/08/22/sstable-summary/#duoshuo">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/2016/08/18/leveldb-write/">
		
			Leveldb源码笔记之写入操作</a>
	</h2>
	<div class="entry-content">
		<h4>插入一条K/V记录</h4>

<p><img src="/images/blog_images/leveldb/writer.png" alt="" /></p>

<h4>持有Writer的线程进入Writers队列,细节如下：</h4>

<p><img src="/images/blog_images/leveldb/writers_queue.png" alt="" /></p>

<h4>MakeRoomForWrite的流程图：</h4>

<p><img src="/images/blog_images/leveldb/make_room_for_write.png" alt="" /></p>

<h4>记录会首先写入磁盘上的binlog，避免程序crash时内存数据丢失：</h4>

<p><img src="/images/blog_images/leveldb/write_to_binlog.png" alt="" /></p>

<blockquote><p>此处我们做了一个极度夸张的假设来做演示:两条记录的大小超出一个block的大小, 以至于被一切为三</p></blockquote>

<h4>K/V记录插入内存中的Memtable:</h4>

<p><img src="/images/blog_images/leveldb/write_to_memtable.png" alt="" /></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2016-08-18T15:03:00+08:00" pubdate data-updated="true">Aug 18<span>th</span>, 2016</time></div>
	<div class="tags">


	<a class='category' href='/tags/distribute/'>distribute</a>, <a class='category' href='/tags/leveldb/'>leveldb</a>


</div>
	
	<div class="comments"><a href="/2016/08/18/leveldb-write/#duoshuo">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/2016/07/20/signal-with-mutex-locked-or-not/">
		
			Signal With Mutex Locked or Not(译)</a>
	</h2>
	<div class="entry-content">
		<p><a href="http://www.domaigne.com/blog/computing/condvars-signal-with-mutex-locked-or-not/">原文链接</a></p>

<h3>介绍</h3>

<p>当我们使用条件变量的时候，总有这样一个问题：到底该在解锁mutex之前进行sinal/broadcast，还是在之后？</p>

<p>什么时候进行signal？</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span><span class='line'><span class="n">predicate</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
</span><span class='line'><span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">);</span>    <span class="c1">// OR: pthread_mutex_unlock(&amp;mutex);</span>
</span><span class='line'><span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">//  : pthread_cond_signal(&amp;cv);</span>
</span></code></pre></td></tr></table></div></figure>


<h3>权威解答</h3>

<p><a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_cond_signal.html">SUS7</a>中提到：</p>

<blockquote><p>当其他线程利用pthread_cond_wait() 或pthread_cond_timedwait() 在关联的条件变量上等待时，当前线程既可以在持有（锁住）mutex时调用pthread_cond_broadcast()或 pthread_cond_signal() ，也可以在不持有mutex的情况下调用。然而，如果需要可预测的线程调度行为，则需要在mutex被锁住的情况下调用pthread_cond_broadcast() 或 pthread_cond_signal()</p></blockquote>

<p>上述具体时什么意思呢？</p>

<h3>锁住mutex时进行signal</h3>

<p>在某些平台上，OS就在 signal/boadcast 之后进行上下文切换（context switch）来唤醒等待线程以达到降低延迟的效果。在一个单处理的系统上，如果我们在持有mutex的情况signal/broadcast则会导致不必要的上下文切换（context switch）.</p>

<ul>
<li><img src="/images/blog_images/signal-ctx-switch.jpg" alt="Fig 1- 锁住mutex时进行signal，我们造成了两次不必要的上下文切换（context switch）" /></li>
</ul>


<p>事实上，考虑figure 1中的场景。线程T2阻塞在条件变量上。当 T1 在持有关联的mutex的情况下 signal 条件变量时，上下文切换至T2导致T2被唤醒。但是在pthread_cond_wait返回之前，T2需要锁住条件变量关联的mutex。然而条件变量关联的mutex此时仍被T1持有（锁住）。结果导致T2被阻塞（由于mutex竞争）并且上下文切换至T1。之后T1解锁条件变量关联的mutex，同时T2最终变为runalbe状态。当我们对多个线程进行条件变量broadcast（多播）时，情况会变的更加糟糕。</p>

<p>有些Pthreds 使用名为 <strong>wait morphing</strong> [1]的优化实现方式来应对这个缺陷。这种优化可以在持有锁的情况下避免上下文切换(context swith)直接将线程从条件变量队列转移至mutex队列。例如 NPTL 使用了<strong>类似的技术</strong>[2]来优化broadcat.</p>

<p>当我们的实现没有使用 wait morphing时，我们可能需要先解锁然后在进行 signal/broadcast. 事实上，解锁操作不会导致上下文切换至T2，因为T2阻塞在了条件变量上。当signal/broadcast之后，T2被唤醒后会发现mutex已经被解锁，便可以持有mutex。</p>

<h3>解锁mutex后signal</h3>

<p>这样（译者注：解锁mutex后signal）存在缺点么？首先我们关注一个不同的情形。如果我们先signal或者broadcast，我们可以确保唤醒一个阻塞在条件变量上的线程（假设存在这样一个线程）。然而，如果我们先解锁，我们可能会唤醒一个阻塞在mutex上的线程。</p>

<p>什么时候会出现这种情形呢？一个thread可能阻塞在mutex上，因为：</p>

<ul>
<li>线程即将检查谓词（译者注：条件变量的等待条件），并且最终会等待在条件变量上</li>
<li>线程即将修改谓词，并且最终会通知等待在条件变量上的线程</li>
</ul>


<p>在第一种情况下，我们可能获取一个被拦截的唤醒。事实上，再次考虑figure 1中的情形，但是存在第三个线程T3，T3阻塞在mutex上(<code>译注：即将检查谓词</code>)。当T1解锁mutex，上下文切换至T3。现在T3发现谓词为真，因此执行相应处理，并且最终会在T1 signal/broadcast 条件变量之前重置谓词。当T2被唤醒，出发唤醒的条件已经不存在。在一个正确的程序设计中，这不是一个问题（<code>译注：只要你不对调度结果有所期待，这肯定不是问题</code>），因为T2总是会应对假唤醒（<code>译注：即使被唤醒也会再次检查谓词</code>）。下面的程序演示了被拦截的唤醒情形。</p>

<p><a href="http://www.domaigne.com/blog/wp-content/plugins/wp-codebox/wp-codebox.php?p=33&amp;download=cv_01.c">Download cv_01.c</a></p>

<p>在第二个例子（<code>译注：即线程即将修改谓词，并且最终会通知等待在条件变量上的线程</code>）里，我们最终延迟了T2的唤醒。实时上，T3可以发现T1已经修改了谓词，并且决定不再signal/broadcast。只要T1不被调度并获得机会signal/broadcast，那么T2会仍旧会阻塞。（<code>译注：一般是不会取消signal的，至少我不知道什么时候会这样做，这里只是假设你这样做了，会有潜在风险，这种风险也可以通过修改设计来避免的</code>）</p>

<h3>考虑实时调度</h3>

<p>在实时系统程序设计中，线程的优先级通常会被截止时间的临界所影响。 概括的说，越临近结束时间，优先级越高。不遵守时限可能会造成系统失败，结果可能会损坏我在之前<a href="http://www.domaigne.com/blog/computing/real-world-systems/">《Real World Sytems》</a>中讨论的环境。</p>

<p>考虑这种情形，你明确的想要最高优先级的线程在变为runnable状态时可以尽快获取CPU时间片，但是低优先级的线程却可能阻止高优先级的线程运行，这种情形被称为优先级倒置。这种情况发生的一个例子就高优先级的线程想要锁住一个已经被低优先级线程持有的mutex。只要优先级倒置的持续时间总是很少或被限制的，这事实就不是一个问题。一个更严重的情况是优先级倒置（潜在的）不被限制, 这可能倒置高优先级的线程错过截止时间，像<strong>优先级顶置</strong>或<strong>优先级继承</strong> [3]这种协议就是被设计来规避这种问题的。</p>

<blockquote><p>译者注：
- 优先级置顶：就是给共享资源设置一个预定的优先级，这个优先级肯定大于所有会请求这个资源的线程，哪个线程获取了资源，它的优先级就提升到这个预定的优先级，这样它就会比高优先级的线程的优先级还高，等当前线程运行完不再持有共享资源，资源会率先被优先级其次的获取，同时当前线程优先级恢复正常，一切继续。这样就避免了中间优先级的线程拦截持有共享资源
- 优先级继承：低优先级的线程获取了共享资源后，优先级不变，当高优先级的线程去请求共享资源时，低优先级的线程的优先级会被短暂提升，直至其释放掉共享资源</p></blockquote>

<p>当使用实时调度策略时，signal/broadcast 操作唤醒最高优先级的线程。如果存在两个或更多线程拥有同样的优先级，会优先选择第一个阻塞在条件变量上的线程。这也是我们所期待的。</p>

<p>然而，条件变量可能被不做限制的优先级倒置以三种方式影响（<code>译注：这三种情况下使用优先级顶置或者优先级继承也没用</code>）。第一种明显的倒置是条件变量关联的mutex，因为mutex自身就会被不做限制的优先级倒置所影响（<code>译注：注意和下面第三种情况做区分，这里仅仅因为mutex解锁，T3恰巧阻塞在锁上，获得锁之后并没干啥和T2相关的事，仅仅就是T3优先级低于T2</code>）。</p>

<p>另外一种优先级倒置可以发生在线程signal/broadcast条件变量之前，再考虑figure 1中的情节，假设T1是一个低优先级（P1）的线程，T2是一个高优先级（P2）的线程（P1 &lt; P2）。只要T1不signal/broadcast，他就就可以被中间优先级（P3）的线程T3抢占（P1 &lt; P3 &lt; P2）（<code>译者注：注意和前一种做区分，这个抢占是cpu正常调度引起的，这里T3并没有请求获取mutex，仅仅是因为P3 &gt; P1</code>）。通常情况，如果选择先解锁再signal/broadcast, T1可以在解锁之后和signal/broadcast之前被抢占。最终T1不会唤醒T2，因此T3阻止了比它优先级更高的T2运行。如果先signal/broadcast，再解锁，我们可以保证T1解锁之后T2可以尽快被调度到，前提是mutex上使用优先级顶置或优先级继承协议（<code>译注：根据我的理解，以优先级顶置为例，T1持有mutex时，优先级会短暂提升到最高，等它释放后，T2就理所当然凭借高优先级，以及不再阻塞在条件变量上，而获取mutex</code>）。所以持有mutex时进行signal/broadcast稍微优于先unlock再singnal/broadcast(<code>译注：假设我们想要的结果是保证在T1进行signal/boadcast之后，T2可以尽快得到cpu时间片</code>)。值得注意的是不管怎样在这两种情形(<code>译注：即是否先解锁再signal/boadcast这两</code>)中，当T1正在修改谓词的时候优先级倒置都可能会发生（<code>译注：根据我的理解，这种调度结果是正常的，毕竟P3&gt;P1，但如果有优先级置顶或者优先级继承协议的话，可以避免这种情况</code>）.</p>

<p>最后一个是，当T3阻塞在mutex上的情形。我么已经在之前分时调度的章节（<code>译注：解锁mutex后signal小节</code>）讨论过了。如果T1在唤醒T2之前解锁，T3将会获得CPU时间片。在拦截唤醒的例子中，条件被修改后本应该T2处理的却被优先级更低的T3给处理了（<code>译注：这个例子强调的是倒置之后本应T2等待的谓词，被T3抢走了，T2继续阻塞</code>）。另一个线程即将修改谓词并且最终会通知等待在条件变量上的线程例子中，我们同样再次被潜在的不受限制的优先级倒置影响。</p>

<p>根据之前的解释，我们相信在要想实时调度的结果可预测(<code>译注：不可预测其实还是蛮严重的，毕竟会导致任务错过deadline</code>)，signal/broadcast之后解锁mutex是必须的。这种判断应该有所节制，我从来没有经历过必须强制执行可预测性的情形。总是有可能去修改设计，所以先解锁未尝不可。事实上，David Butenhof 在最近的文章中写道，在SUS标准中的实时可预测陈述本质上是政治而不是技术[4]。但这已经被实时工作组的成员追捧起来，并且为了避免投票过程中潜在的反对也已经在SUS标准稳定下来。</p>

<h3>一个陷阱 （A Trap）</h3>

<p>存在一个案例，如果你先unlock会令你陷入问题中。你必须确保当你解锁mutex之后你所signal/broadcast的条件变量依旧引用的是一个有效的条件变量。这听起来似乎是显而易见的，但是在实践中一直确保这一点并不轻松[5]. 特别的，如果正在被唤醒的线程中销毁条件变量（亦或者条件变量所在的内存）则需要拉响警报了。</p>

<p><a href="http://www.domaigne.com/blog/wp-content/plugins/wp-codebox/wp-codebox.php?p=33&amp;download=cv_02.c">Download cv_02.c</a></p>

<p>上述程序运行在至少双核的机器上，在反复几千次后被SIGSEGV信号所终止。问题在56-59行。问题发生在在负责停止的线程发现nthread为0时会销毁条件变量，但是稍后在线程池中的线程会尝试signal已经不存在的条件变量。如果我们先signal然后再解锁，程序运行就不会有问题。</p>

<h3>结论</h3>

<p>我个人选择在持有mutex的情况下进行signal/boadcast.首先，我可以避免一些晦涩的bug。其次，这样做在使用wait morphing优化实现的pthread中几乎没有性能影响。再者，更重要的一点，我认为当且仅当经过分析有明显的性能提升时才会将解锁放在signal/boadcast之前。对瓶颈没有贡献的优化是没有意义的。</p>

<h3>引用以及推荐阅读</h3>

<ul>
<li>[1] David R. Butenhof: Programming with POSIX Threads, section 3.3.3, pp 82-83, Addison-Wesley, ISBN-13 978-0-201-63392-4.]</li>
<li>[2] <a href="https://www.akkadia.org/drepper/futex.pdf">Ulrich Drepper. Futexes Are Tricky</a>. A paper about futex, the Linux kernel object behind condition variable. See in particular the Chapter 8 “Optimizing Wakeup” on page 9-10.</li>
<li>[3] <a href="http://www.cs.rice.edu/~mgricken/teaching/402/09-spring/readings/PriorityInversion.html">Kyle &amp; Bill Renwick. How to use priority inheritance</a>. An excellent article from embedded.com about priority inversion and possible cures.</li>
<li>[4] <a href="https://groups.google.com/forum/#!topic/comp.programming.threads/wEUgPq541v8">basic question about concurrency</a>. A discussion thread on c.p.t, where David Butenhof explains what the “predictable scheduling” statement in the SUS standard means and where it comes from.</li>
<li>[5] <a href="http://groups.google.de/group/comp.programming.threads/browse_thread/thread/23dd5883dc36d14a/7e5fcdf360543375">A word of caution when juggling pthread_cond_signal/pthread_mutex_unlock</a> . A post from Bryan Ischo on c.p.t. that shows a subtle bug when unlocking before signaling.</li>
</ul>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2016-07-20T16:48:00+08:00" pubdate data-updated="true">Jul 20<span>th</span>, 2016</time></div>
	<div class="tags">


	<a class='category' href='/tags/concurrency/'>concurrency</a>, <a class='category' href='/tags/system/'>system</a>


</div>
	
	<div class="comments"><a href="/2016/07/20/signal-with-mutex-locked-or-not/#duoshuo">Comments</a></div>
	
</div>
</article>

<nav id="pagenavi">
    
        <a href="/" class="prev">Prev</a>
    
    
        <a href="/blog/page/3/" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav></div>
	<footer id="footer" class="inner">Copyright &copy; 2019

    Travis Swicegood

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->
<!--

 -->

	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-50190414-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>




</body>
</html>